% code.tex

\documentclass{pracamgr}
%\usepackage{z-eves}
% z and oz - mixed by code
\usepackage{code-z}
\usepackage{tocbibind}
\usepackage{fancyhdr}
\usepackage{graphics}
\usepackage[polish]{babel}
\usepackage{t1enc}
\usepackage[latin2]{inputenc}

% troche moich definicji
\def \zet {${{\bbold Z} }$ }
\def \nowalinia {\hspace*{\fill} \\}
\def \items {\it{idem}~}

\ifx\pdfoutput\undefined \newcount\pdfoutput \fi
\ifcase\pdfoutput

% dvi,ps

\else

% pdf
% U¿yj fontów times gdy zamieniasz do PDF
\usepackage{times}
\usepackage[pdftex,colorlinks=true,
                      pdfstartview=FitV,
                      linkcolor=blue,
                      citecolor=blue,
                      urlcolor=blue,
          ]{hyperref}
          \pdfinfo{
            /Title      (Z-notacja jako narzêdzie specyfikacji formalnej)
            /Author     (Maciej Mochol)
            /Keywords   (Z, Z-notacja, metody formalne)
          }
%\usepackage{thumbpdf}

\fi

% Praca
\title{Z-notacja jako narzêdzie specyfikacji formalnej}
\author{Maciej Mochol}
\date{Warszawa, \today}
\opiekun{dr. in¿. Henryk Dobrowolski}

\keywordspol{Z, Z-notacja, metody formalne}
\abstractpol{
Praca ta przedstawia w przekrojowy sposób zastosowanie metod formalnych do
projektowania i weryfikacji oprogramowania, ze szczególnym uwzglêdnieniem
notacji Z jako jêzyka specyfikacji.  Zosta³y w niej zawarte informacje na
temat dowodzenia poprawno¶ci, metod i narzêdzi do automatycznej analizy
specyfikacji, oraz zarysu standardu ISO.
}

\titleang{Z-notation as a tool for a formal specification}
\keywordsang{Z, Z-notation, formal methods}
\abstractang{
This thesis describes using the formal methods in a software development and
verification, with special allowance of the Z notation as a specification
language. There is information included showing the proof, methods and tools
for an automatic specification analysis and an outline of ISO standard.
}

\begin{document}
\selectlanguage{polish}

\maketitle
\makeabstract
\tableofcontents

% fancyhdr - nag³ówki i stopki

\fancyhead[LE,RO]{}
\fancyhead[LO]{\slshape \leftmark}
\fancyhead[RE]{\slshape \rightmark}
\pagestyle{fancy}

\chapter{Wstêp}

Wspó³czesne oprogramowanie staje siê coraz wiêksze i bardziej skomplikowane. 
W przypadku niewielkich systemów, mo¿liwe jest aby jeden cz³owiek rozumia³
wszystkie aspekty tworzonego kodu, jednak dotyczy to projektów sk³adaj±cych
siê z 5 lub 6 uczestników (a i tu mo¿na by polemizowaæ, ¿e zale¿y to od
wielu czynników i nawet ta granica mo¿e siê okazaæ zbyt du¿a). Dla wiêkszych
implementacji staje siê to niemo¿liwe. Wiêkszo¶æ profesjonalnie
projektowanego oprogramowania posiada dokumentacjê projektow±, z dok³adn±
specyfikacj± dokumentuj±c± dzia³anie systemu, funkcjonalno¶æ, jego
zachowanie w sytuacjach wyj±tkowych i awaryjnych, itp. Te specyfikacje
pisane s± w fazie poprzedzaj±cej implementacjê i maj± s³u¿yæ jako ¼ród³o
informacji dla programistów w fazie pisania kodu, zbiór referencji dla ekipy
testuj±cej nowo powsta³e oprogramowanie czy te¿ punkt odniesienia dla osób
pisz±cych instrukcjê lub te¿ negocjuj±cych z klientem.  Specyfikacja jest
wspólnym obszarem danych wszystkich osób zaanga¿owanych w projekt.
Podkre¶liæ nale¿y, ¿e opisuje ona co ma system robiæ, a nie w jaki sposób,
jest te¿ ca³kowicie niezale¿na od kodu, przez co mo¿e byæ ukoñczona we
wczesnym etapie projektu.

Zale¿nie od przyjêtej strategii projektowej specyfikacje maj± ró¿ny
kszta³t, zawieraj± równie¿ ró¿n± tre¶æ. Nie ma uniwersalnego sposobu na
tworzenie dobrych specyfikacji, zale¿y to czêsto równie¿ od wykorzystywanych
technologii, rodzaju projektu lub te¿ od innych czynników - np. konieczno¶æ
wspó³pracy z innymi systemami. Niemniej jednak wszystkie specyfikacje maj±
wspólny cel - w sposób jasny i zrozumia³y powinny wyja¶niaæ wszystkie
aspekty danego systemu, w³±czaj±c w to jego funkcjonalno¶æ, format danych,
scenariusze u¿ycia, opis u¿ytkowników i ich uprawnienia, sposób radzenia
sobie z sytuacjami wyj±tkowymi.

Zazwyczaj taka specyfikacja powstaje przy u¿yciu jêzyka naturalnego,
wszystkie jej elementy s± dok³adnie opisane jêzykiem zrozumia³ym dla
cz³owieka. Niestety czêsto prowadzi to do nieporozumieñ, bowiem okazuje siê,
i¿ w wielu sytuacjach programista odbiera tekst napisany przez projektanta
niekoniecznie tak, jak ¿yczy³by sobie tego ten pierwszy, a to z powodu
faktu, ¿e jêzyk ludzki obfituje w pu³apki i wieloznaczno¶ci. 

Dlatego od kilkunastu lat obserwujemy rosn±ce zainteresowanie formalnymi
metodami specyfikacji i projektowania oprogramowania. Metody takie
maj± g³ówn± zaletê: dziêki formalizmowi jest dok³adnie wiadomo, co
dany zapis przedstawia, nie ma miejsca na wieloznaczno¶ci lub nieporozumienia. 
Zapisy formalne mog± byæ poddane automatycznej analizie w celu
wykrycia b³êdów i nie¶cis³o¶ci, a nawet mog± pos³u¿yæ do matematycznego 
udowodnienia poprawno¶ci danego projektu.

Celem tej pracy by³o zbadanie dostêpnych metod i narzêdzi, które nadaj±
siê do praktycznego wykorzystania w projektowaniu i implementacji systemów
komputerowych. Pomimo tego, ¿e jest ich wiele, niektóre nadal s± w fazie 
badañ, a inne z kolei wystarczaj± do pracy z jedn± klas± problemów, bêd±c
bezu¿ytecznymi dla innej.

W niniejszym dokumencie przedstawiê metody i narzêdzia do formalnego opisu
systemów, ze szczególnym naciskiem na {\bf notacjê \zet}, która 
jako jedna z metod ¶cis³ego projektowania specyfikacji z wykorzystaniem
aparatu matematycznego, wyró¿nia siê funkcjonalno¶ci± i uniwersalno¶ci±.

Praca sk³ada siê z czê¶ci teoretycznej i praktycznej.

W czê¶ci teoretycznej czytelnik znajdzie wprowadzenie do notacji \zet oraz
matematycznych podstaw - logiki pierwszego rzêdu, rachunku predykatów i
teorii mnogo¶ci (w ujêciu teorii zbiorów Zermelo-Fraenkel), niezbêdnych do
tworzenia formalnej specyfikacji. Opisanym elementom notacji towarzysz±
przyk³ady zastosowañ, nawi±zuj±ce do tradycyjnych metod zapisu algorytmów i
struktur danych.

Oprócz tego podane s± metody dowodzenia poprawno¶ci specyfikacji -
wraz z podstawowymi technikami wyprowadzania dowodów.

Czê¶æ praktyczna pomo¿e potencjalnym projektantom oprogramowania w
zapoznaniu siê z dostêpnymi narzêdziami, wspomagaj±cymi sprawdzanie 
poprawno¶ci zapisów oraz weryfikacji formalnej specyfikacji.

Czê¶æ praktyczna zawiera formalny opis rzeczywistego systemu StockPack;
u¿ycie metod formalnych u³atwi³o jego projekt i implementacjê.

Autor zak³ada, ¿e czytelnikowi znany jest aparat matematyczny le¿±cy u 
podstaw notacji. 

\chapter{Wprowadzenie do notacji \zet}
 
\section{Podstawy notacji \zet}

{\bf \zet} jest notacj± formalnej specyfikacji, opart± na teorii zbiorów
Zermelo-Fraenkel, logice pierwszego rzêdu oraz rachunku predykatów. Zosta³a
zaprojektowana na uniwersytecie w Oksfordzie (Programming Research Group at
OUCL) w pó¼nych latach siedemdziesi±tych. Jest wykorzystywana jako czê¶æ
procesu produkcji oprogramowania w Europie oraz w USA. W 2002 powsta³
oficjalny standard ISO/IEC 13568 \cite{ISO}.

Jest to jêzyk wykorzystywany w specyfikacji, a nie implementacji.
Nie ma wiêc narzêdzia pe³ni±cego rolê kompilatora lub linkera. S± projekty,
które badaj± wykorzystanie \zet do szybkiego tworzenia prototypów funkcji, jednak 
idea tego jêzyka pod±¿a w zupe³nie innym kierunku. Notacja ta zosta³a 
zaprojektowana w celu podwy¿szenia czytelno¶ci specyfikacji projektu przez
ludzi, oraz dostarczenia metod formalnej specyfikacji. 

Dlatego potencjalny projektant ma do dyspozycji w³a¶ciwo¶æ niedostêpn±
jêzykom programowania, a mianowicie niedeterminizm. Specyfikacja mówi nam
bowiem, CO program ma robiæ, a nie w JAKI sposób. Dziêki temu programista
tworz±cy konkretny kod ma pewn± wolno¶æ, poniewa¿ projekt nie narzuca mu
sposobu implementacji. Formalna specyfikacja okre¶la dzia³anie programu,
które mo¿na osi±gn±æ ró¿nymi metodami, zatem dopiero w fazie implementacji
trzeba okre¶liæ, która z nich jest najbardziej efektywna.

Co wiêcej niedeterminizm ten pozwala na stopniowe budowanie specyfikacji,
poprzez stopniowe uszczegó³owianie jej. Formalnie poprawny jest pocz±tkowy
projekt wyznaczaj±cy g³ówne ramy systemu, jak równie¿ koñcowy, który zawiera
informacje o wszystkich detalach zwi±zanych z jego dzia³aniem.

W praktyce u¿ycie tej specyfikacji polega na przeplataniu tekstu
napisanego w jêzyku naturalnym zapisów formalnych, przez co projektant
od razu wyja¶nia przy¶wiecaj±ce mu idee, popieraj±c je
odpowiednimi wzorami. Najczê¶ciej u¿ywa siê w tym celu systemu
{\LaTeX}, poniewa¿ pozwala on na automatyczn± obróbkê i z³o¿enie tekstu
oraz zapisów, a do tego postaæ elementów jêzyka \zet jako makr {\LaTeX} jest
w³a¶ciwie standardem i s³u¿y jako zamiennik ASCII notacji w formie symboli
matematycznych. Makra te mog± byæ wprowadzane na wej¶cie
narzêdzi sprawdzaj±cych poprawno¶æ zapisu {\bf (type-checkers)} lub innych.

Notacja \zet sk³ada siê w³a¶ciwie z dwóch jêzyków: matematycznego oraz
schematów. 

\section{Przyk³ady rzeczywistych projektów, w których zastosowano \zet}

Najs³ynniejszym projektem, który zosta³ zaprojektowany z u¿yciem notacji Z
jest wspólne przedsiêwziêcie firmy IBM Labolatories at Hursley (Wielka
Brytania) i Programming Research Group na Oxford University Computing
Labolatory, znane jako projekt CICS.  Projekt rozpoczêto w 1981 i w ramach
niego opracowano specyfikacjê kilkunastu czê¶ci wchodz±cych w sk³ad systemu
przetwarzania transakcji {\bf IBM CICS}, szeroko wykorzystywanego w
komputerach klasy {\em mainframe}. Szersze informacje mo¿na znale¼æ w
\cite{CICS_Report}.

Inne znane projekty:

\begin{itemize}

\item{} System komputerowej kontroli urz±dzenia medycznego, s³u¿±cego do
klinicznej terapii neutronowej opartej na cyklotronie, które jest u¿ywane na
Uniwersytecie Waszyngton w Seattle do leczenia raka. Funkcjonalno¶æ systemu
zosta³a opisana z u¿yciem zbioru narzêdzi do projektowania w \zet systemów
sterowania o podwy¿szonym poziomie bezpieczeñstwa \cite{Machine_Jacky}.

\item{} Projekt formalnego opisu regu³ bezpieczeñstwa dla systemu {\bf NATO
ACCS} (ang. {\it Air Command and Control System}). W ramach niego sporz±dzono
formaln± specyfikacjê, ³±cznie z atestacj± czê¶ci specyfikacji wykonan± z
u¿yciem tradycyjnych metod. Dostêpny jest raport \cite{NATO_ACCS}
zawieraj±cy wyniki.

\item{} Specyfikacja regu³ sygnalizacji Kolei Brytyjskich, jako czê¶æ
dokumentu opisuj±cego wymagania dla systemu prze³±czania trakcji kolejowych.
Specyfikacja zosta³a napisana w \zet przez firmê Praxis Systems dla British
Rail's Network SouthEast (obecnie Railtrack). Ich do¶wiadczenia opisane s± 
w \cite{British_Rail}.

\item{} Implementacja mechanizmu transakcji dla {\bf SWORD} - systemu
relacyjnych baz danych. Jego celem jest kontrola wielu transakcji dostêpu do
bazy, bez niepotrzebnego blokowania danych. Podsumowanie projektu
\cite{SWORD} zawiera równie¿ specyfikacjê \zet tego mechanizmu.

\end{itemize}

\section{Jêzyk matematyczny notacji}

Jêzyk matematyczny wykorzystywany w notacji s³u¿y do opisu obiektów, oraz
relacji zachodz±cych pomiêdzy nimi. Sk³ada siê z zestawu typów i operatorów,
co mo¿na porównaæ do biblioteki standardowej jêzyka programowania, z³o¿onej
z typów i funkcji.

Wszystkie operatory \zet bazuj± na fundamentalnych koncepcjach zaczerpniêtych
z logiki oraz teorii mnogo¶ci. Czê¶æ z nich to anatomiczne pojêcia
matematyczne takie jak zbiór, iloczyn kartezjañski, albo relacja wiêkszo¶ci.
Pozosta³e s± pochodnymi tych pojêæ, wyprowadzonymi zgodnie z regu³ami
zastosowanego aparatu matematycznego.

Poniewa¿ jak zosta³o to opisane poprzednio, notacja nie jest jêzykiem
programowania, lecz narzêdziem do budowania specyfikacji; formalne zapisy
nie musz± siê sk³adaæ jedynie z zapisów matematycznych. Czêsto w
przypadkach, kiedy trudno jest zdefiniowaæ dane pojêcie, stosuje siê opisy w
jêzyku naturalnym, ³atwo zrozumia³ym dla cz³owieka (np. zbiór skoñczony). W
dalszych etapach specyfikowania i dokumentowania systemu zapisy te mog± byæ
sformalizowane.

Czê¶æ matematyczna notacji s³u¿y do okre¶lenia poziomu abstrakcji, dziêki
czemu zachowania systemu mog± byæ opisane za pomoc± bogatej kolekcji praw
matematycznych. Nie jest ona zorientowana na typowo komputerowe podej¶cie
okre¶lenia formatu danych czy opisu algorytmów, ale na maksymalne
wykorzystanie jej mechanizmów i logiki do stworzenia spójnego i formalnego
opisu.

W rozdziale tym zostanie krótko omówione wykorzystanie elementów notacji,
natomiast zestawienie operatorów i definicji znajduje siê w dodatku A. \zet
to bardzo bogata notacja, zatem nie wszystkie jej elementy tutaj opisano,
koncentruj±c siê tylko na podstawowych i najczê¶ciej wykorzystywanych
zapisach. Dla tworzenia rzeczywistych specyfikacji mo¿e siê okazaæ niezbêdne
skorzystanie z referencji jêzyka, jak± jest ksi±¿ka Spivey'a
\cite{Spivey-ZRM}, pe³ni±ca przez d³ugi czas funkcjê standaryzacji \zet,
oraz z opisu miêdzynarodowego standardu ISO \cite{ISO}.

\subsection{Zbiory}

Pojêcia zbiorów znane z teorii mnogo¶ci s± kluczowym elementem \zet,
poniewa¿ wykorzystywane s± do modelowania danych. Ich zastosowanie w
specyfikacji jest do¶æ intuicyjne, podobnie jak innych pokrewnych pojêæ
takich jak: suma, ró¿nica, iloczyn, potêga zbiorów, zbiór pusty, oraz
relacje zawierania siê i niezawierania.

Korzystaj±c z tych elementów mo¿na wygodnie opisywaæ struktury danych.
Nadaj± siê one te¿ do projektowania baz danych \footnote{praca Barrosa
\cite{Barros_phd} jest prób± formalnego opisu relacyjnych baz danych,
wprowadzaj±cego definicje podstawowych pojêæ jak tabela, indeks, klucz
obcy, lub transakcja.}.  W zestawieniu z kwantyfikatorami i sekwencjami
mo¿emy strukturalizowaæ dane oraz specyfikowaæ ich format.

\subsection{Pary i relacje binarne}\label{r:pairs_relations}

Je¶li $x \in X$ i $y \in Y$, to zbiorem wszystkich par uporz±dkowanych 
$(x, y)$ jest iloczyn zbiorów (produkt kartezjañski) $X \cross Y$. Relacj±
binarn± $R$ nazywamy dowolny podzbiór $X \cross Y$. Je¿eli para $(x, y) \in
R$, to mówimy, ¿e elementy $x, y$ s± ze sob± w relacji i zapisujemy $x~R~y$.

Praktycznym zastosowaniem tych pojêæ jest mo¿liwo¶æ powi±zania ze sob± dwóch
zbiorów w/g okre¶lonych regu³. Oto przyk³ady.

Mamy dwa zbiory: u¿ytkowników i uprawnieñ.

\begin{zed} [UZYTKOWNICY, UPRAWNIENIA] \end{zed}

Teraz wi±¿emy te dwa zbiory, u¿ytkownik jest uprawniony do czego¶,
je¶li jest w poni¿szej relacji. Relacja ta opisuje uprawnienia u¿ytkowników.

\begin{zed}
	RELACJA: UZYTKOWNICY \rel UPRAWNIENIA
\end{zed}

Przyk³adowa para, bêd±ca elementem relacji. Adam mo¿e zak³adaæ konta.

\begin{zed} (ADAM,ZAKLADANIEKONT) \end{zed}

lub

\begin{zed} ADAM \mapsto ZAKLADANIEKONT \end{zed}

Zbiór pierwszych elementów wszystkich par, czyli dziedzina. W tym przypadku
zbiór wszystkich u¿ytkowników uprawnionych do czego¶:

\begin{zed} 
	\dom RELACJA
\end{zed}

Zbiór drugich elementów - czyli zbiór wszystkich uprawnieñ posiadanych przez
u¿ytkowników:

\begin{zed}
	\ran RELACJA
\end{zed} 

Zdefiniujmy jaki¶ zbiór u¿ytkowników:

\begin{zed}
	U: \power UZYTKOWNICY
\end{zed}

Przydatny mo¿e byæ obraz relacyjny. Poni¿szy zapis oznacza zbiór
wszystkich uprawnieñ nadanym u¿ytkownikom ze zbioru U.
\begin{zed}
	RELACJA \limg U \rimg
\end{zed}

\subsection{Liczby i arytmetyka}

W notacji \zet s± zdefiniowane liczby ca³kowite $\num$ i naturalne $\nat$.
Ponadto okre¶lone s± typowe operacje arytmetyczne, arytmetyka modulo,
liczno¶æ zbioru, oraz minimum i maksimum zbiorów (ze zdefiniowanymi
relacjami porównania).

W \zet nie ma pojêcia liczb rzeczywistych \footnote{W stosunku do ZRM
\cite{Spivey-ZRM} pojêcie liczb zosta³o jednak nieco rozbudowane w
standardzie ISO \cite{ISO}. Zosta³ zdefiniowany specjalny typ ${\bbold A}$
'arithmos', na którym oparto definicjê liczb ca³kowitych. W ten sam sposób
mo¿na zdefiniowaæ liczby rzeczywiste i inne, nie uczyniono tego jednak w
standardzie.}. Przyk³ad zdefiniowania zbioru liczb (którego podzbiorem
by³yby liczby naturalne) jest w \cite{Arthan_arithmetic}. Praca \cite{Reals}
przedstawia szczegó³owy model liczb rzeczywistych {${{\bbold R} }$ }
wyra¿ony w \zet za pomoc± sekwencji cyfr, wraz z czê¶ciowym dowodem ich
w³a¶ciwo¶ci.

\subsection{Funkcje}

Funkcje maj± podobne zastosowanie jak relacje, kiedy chcemy powi±zaæ ze sob±
dwa zbiory danych. W/g przyk³adu z punktu \ref{r:pairs_relations} mogliby¶my
zdefiniowaæ funkcjê, która zwraca uprawnienia u¿ytkownika. W przyk³adzie
zastosowano potêgê, poniewa¿ funkcja oczywi¶cie nie mo¿e zwracaæ
wielu uprawnieñ, ale mo¿e zwracaæ podzbiór zbioru $UPRAWNIENIA$.

\begin{zed}
	UZYTKOWNICY \pfun \power UPRAWNIENIA
\end{zed} 

Jest to funkcja czê¶ciowa, bo nie wszyscy u¿ytkownicy musz± mieæ uprawnienia
(tzn. niektóre elementy zbioru $UZYTKOWNICY$ s± w parze z elementem ze
zbioru \nowalinia $UPRAWNIENIA$).  Gdyby¶my chcieli zapewniæ, aby wszystkim
u¿ytkownikom przypisano uprawnienia, mogliby¶my napisaæ:

\begin{zed}
	UZYTKOWNICY \fun \power UPRAWNIENIA
\end{zed} 

Do dyspozycji projektanta dostêpne s± równie¿ injekcje i bijekcje.
Przyk³adowo zak³adaj±c, ¿e uprawnieñ jest tyle samo co u¿ytkowników (tzn.
liczno¶æ zbioru $UPRAWNIENIA$ jest równa liczno¶ci zbioru $UZYTKOWNICY$), 
oraz ¿e ka¿dy u¿ytkownik mo¿e mieæ jedno uprawnienie, inne ni¿ pozosta³ych
u¿ytkowników, to mo¿emy napisaæ bijekcjê:

\begin{zed}
	UZYTKOWNICY \bij UPRAWNIENIA
\end{zed}

\subsection{Ci±gi (sekwencje)}

Ci±gi s± wykorzystywane do opisywania struktur danych, w których wa¿na jest
kolejno¶æ. Za pomoc± ci±gów mo¿na opisywaæ m. in. kolejki, strumienie danych
lub pakiety w sieciach komputerowych. W jêzyku matematycznym \zet zdefiniowane 
jest pojêcie ci±gów skoñczonych, wraz z zestawem operacji na nich.

Wyra¿enie $\seq X$ oznacza zbiór wszystkich ci±gów skoñczonych z $X$.
Jego definicj± jest

\begin{zed}
	\seq X == \{~ f : \nat \ffun X | \dom f = 1 \upto \# f ~\}
\end{zed}

We¼my przyk³ad:

\begin{zed}
	KOLEJKA: \seq \nat
\end{zed}

Powy¿sza definicja mówi zatem o ci±gu liczb naturalnych. 

Poniewa¿ sekwencje zdefiniowane s± jako skoñczone funkcje czê¶ciowe, czyli
zbiory par, zawarto¶æ kolejki mo¿e byæ zapisana jako:

\begin{zed}
	\{~ 1 \mapsto x_1, \dots, n \mapsto x_n ~\}
\end{zed}

lub w skrócie

\begin{zed}
	\langle x_1, \dots, x_n \rangle
\end{zed}

$i$-ty element w kolejce to $KOLEJKA(i)$.

$KOLEJKA$ mo¿e byæ pusta ($~\langle \rangle~$), to znaczy mo¿e nie zawieraæ
¿adnego elementu. Aby zagwarantowaæ wystêpowanie co najmniej jednego
elementu w $KOLEJKA$, nale¿y zapisaæ:

\begin{zed}
	KOLEJKA: \seq_1 \nat
\end{zed}

Przyk³adowo, zapis

\begin{zed}
	LICZBA: \seq_1 \{~ 0, 1 \}~
\end{zed}

oznacza liczby zapisane w postaci binarnej.

Kolejne pojêcie to ci±g pokrywaj±cy {\it (ang. injective sequence) }. Jego
definicj± jest:

\begin{zed}
	\iseq X == \seq X \cap (\nat \pinj X)
\end{zed}

Jest to zatem zbiór skoñczonych ci±gów z $X$, które nie zawieraj± 
powtarzaj±cych siê elementów.

Analogicznie do powy¿szego przyk³adu:

\begin{zed}
	LICZBA: \iseq \{~ 0, 1 \}~
\end{zed}

Wedle tej definicji, prawd± jest, ¿e:

\begin{zed}
	LICZBA \in \{~ \langle \rangle, \langle 0 \rangle, \langle 1 \rangle, \langle 0,1 \rangle, \langle 1,0 \rangle \}~
\end{zed}

Na ci±gach mo¿na wykonywaæ operacjê konkatenacji $(\cat)$, mo¿na te¿
stwierdziæ czy $A$ jest podci±giem $B$ $(A \inseq B)$. W \zet zdefiniowano
kilkana¶cie innych operacji i operatorów na sekwencjach (np. $rev$, $tail$,
$\extract$, $\filter$, $\dcat$), których opis pomijamy.

\subsection{Wielozbiory}

Wielozbiór jest pochodn± pojêæ zbioru i sekwencji. Mo¿e on zawieraæ wiele
elementów (tak jak w sekwencji), ale nie jest na nich okre¶lona kolejno¶æ
(tak jak w zbiorze). Definicja:

\begin{zed}
	\bag X == X \pfun \nat_1
\end{zed}

Oznacza to, ¿e niektórym elementom ze zbioru $X$ jest przyporz±dkowana liczba
wyst±pieñ w wielozbiorze ($> 1$). Aby podaæ elementy wielozbioru, stosowana 
jest notacja:

\begin{zed}
	\lbag a, b, b, c \rbag
\end{zed}

Wielozbiór mo¿e byæ pusty ($\lbag \rbag$). S± na nim zdefiniowane:

\begin{itemize}

\item{} liczno¶æ ($\#$ lub $count$), która definiuje ilo¶æ wyst±pieñ elementu $x$ 
w wielozbiorze $B$, co zapisuje siê jako $B \# x$ (lub $count~ B~ x$)

\item{} operator skalowania ($\otimes$). Je¶li $n$ jest liczb± naturaln±, a $B$
wielozbiorem, to $n \otimes B$ jest wielozbiorem, w którym ka¿dy element $x$
wystêpuje $n-$krotn± ilo¶æ razy czê¶ciej ni¿ w $B$.

\item{} relacja przynale¿no¶ci ($\inbag$). $x \inbag B$ jest spe³niona, je¶li
element $x$ wystêpuje w $B$ co najmniej raz.

\item{} relacja zawierania `podwielozbioru' ($\subbageq$). Je¶li $B \subbageq C$, 
to ka¿dy element wielozbioru $B$ wystêpuje w nim nie czê¶ciej, ni¿ w $C$.

\item{} suma ($\uplus$). Ka¿dy element $x$ wielozbioru $B \uplus C$ wystêpuje w
nim tyle razy, ile ³±cznie w $B$ i $C$.

\item{} ró¿nica ($\uminus$). Ka¿dy element $x$ wielozbioru $B \uminus C$ wystêpuje w
nim tyle razy ile $B$ minus ilo¶æ wyst±pieñ w $C$. Je¶li element wystêpuje czê¶ciej
w $C$ ni¿ w $B$, to nie wystêpuje on w ró¿nicy $B \uminus C$.

\end{itemize}

Je¶li nie interesuje nas kolejno¶æ elementów w sekwencji, to ³atwo mo¿emy j±
przekonwertowaæ na wielozbiór za pomoc± operatora $\items$. Je¶li $s$ jest
sekwencj±, to

\begin{zed}
	\items s
\end{zed}

jest wielozbiorem, w którym ka¿dy element $x$ wystêpuje dok³adnie tyle samo razy, 
w sekwencji $s$.

U¿ytecznym przyk³adem zastosowania wielozbioru jest specyfikacja koszyka z zakupami.
Mamy zatem:

\begin{schema}{Zakupy}
	Koszyk : \bag TOWARY
\end{schema}

Typowe operacje na koszyku:

\begin{zed}
Dodaj \defs [~ \Delta Zakupy; co? : TOWARY | Koszyk' = Koszyk \uplus \lbag co? \rbag ~]
\end{zed}

\begin{zed}
Wyjmij \defs \\
\t1	[~ \Delta Zakupy; co? : TOWARY | co? \inbag Koszyk \land Koszyk' = Koszyk \uminus \lbag co? \rbag ~]
\end{zed}

\begin{zed}
Ilosc \defs [~ \Xi Zakupy; co? : TOWARY; ilosc! : \nat | ilosc! = Koszyk \# co? ~]
\end{zed}

$Ilosc$ mo¿e te¿ byæ zdefiniowana jako funkcja, a nie operacja:

\begin{zed}
ilosc = (\lambda x : \dom Zakupy.Koszyk @ Zakupy.Koszyk \# x)
\end{zed}

\subsection{Predykaty}

Notacja \zet jest oparta na logice pierwszego rzêdu (ang. {\it FOL - First-Order Logic}).
Oprócz dobrze znanego rachunku zdañ (m.in. operatory $\land$, $\lor$, $\implies$, $\iff$, etc.), 
wykorzystuje siê rachunek predykatów. S± one postaci:

\begin{zed}
	Qx : a | p @ q
\end{zed}

gdzie:

\begin{tabular}{l l c l}
~	& $Q$ & ~-~ & kwantyfikator \\
~	& $x$ & ~-~ & zmienna wi±zana (ang. {\it bound variable}) \\
~	& $a$ & ~-~ & zakres $x$ \\
~	& $p$ & ~-~ & ograniczenie (ang. {\it constraint}) \\
~	& $q$ & ~-~ & predykat \\
\end{tabular}

\nowalinia

W³a¶ciwo¶ci predykatów:

\begin{zed}
\t1	(\exists x : a | p @ q) \iff (\exists x : a @ p \land q) \\
\t1	(\forall x : a | p @ q) \iff (\forall x : a @ p \implies q) \\
\t1	(\exists x : a @ \exists y : b @ p) \iff (\exists x : a; y : b @ p)
\end{zed}

Predykat mo¿e mieæ warto¶æ {\it true} lub {\it false}, co mo¿e byæ
bezpo¶rednio zapisane w notacji (nie mo¿e mieæ 'niezdefiniowanej' warto¶ci).

Nale¿y pamiêtaæ, ¿e predykaty nie mog± byæ u¿ywane do modelowania relacji
lub funkcji (co jest czêstym b³êdem) tylko raczej do opisu ich w³a¶ciwo¶ci.
Nie ma predefiniowanego typu {\it Boolean}; chocia¿ mo¿na zdefiniowaæ typ
zmiennej o warto¶ciach binarnych, to lepiej tego unikaæ.

Podczas przekszta³cania predykatów czêsto wystêpuje problem redukcji
kwantyfikatorów. Maj±c wyra¿enie postaci:

\begin{zed}
(\exists x : X @ x = E \land \dots x \dots)
\end{zed}

mo¿emy pozbyæ siê kwantyfikatora egzystencjalnego przez zastosowanie `regu³y
jednego punktu' (ang. {\it one-point rule}), która polega na zapisaniu
równowa¿nego predykatu, w którym usuwamy kwantyfikator i równo¶æ $x = E$, a
w pozosta³ej czê¶ci zamieniamy wszystkie wyst±pienia $x$ na $E$.

\subsection{$\xmu-$notacja}

Maj±c dany predykat/ograniczenie - aby stwierdziæ, ¿e istnieje tylko jeden
zestaw warto¶ci zmiennych, które go spe³niaj± - mo¿emy u¿yæ $\mu-$notacji:

\begin{zed}
	(\mu x : a | p)
\end{zed}

Zapis taki okre¶la unikalny element $x$ nale¿±cy do $a$, taki ¿e $p$.

\nowalinia
Przyk³adowo:

\begin{zed}
	2 = (\mu n : \nat | 4 + n = 6)
\end{zed}

Jedyn± liczb± naturaln±, która po dodaniu do $4$ daje $6$ - jest $2$.

\subsection{$\xlambda-$notacja}

Notacja taka jest u¿ywana do skrócenia definicji funkcji. Maj±c dan±
funkcjê:

\begin{zed}
	f = \{~ x : X | p @ x \fun e \}~
\end{zed}

Mo¿emy zapisaæ to samo:

\begin{zed}
	f = (\lambda x : X | p @ e)
\end{zed}

Zbiorem argumentów funkcji s± elementy z $X$, które spe³niaj± wymaganie $p$.
Ka¿demu $x$ jest wtedy przyporz±dkowane $e$.

\nowalinia
Przyk³ad - funkcja kwadratowa:

\begin{zed}
	sqr = (\lambda x : \num @ x * x)
\end{zed}

Funkcja $min$:

\begin{axdef}
	min: \power \nat \pfun \nat
\where
	min = (\lambda s : \power \nat | s \neq \emptyset @ \\
\t2		(\mu x : s | \forall y : s | y \neq x @ y > x))
\end{axdef}

\subsection{Wyra¿enia warunkowe - {\bf if then else}}

Wyra¿enie takie ma postaæ:

\begin{zed}
\t1	\IF P \THEN E1 \ELSE E2
\end{zed}

gdzie $P$ jest predykatem, natomiast $E1$ i $E2$ to wyra¿enia. Warunkiem
poprawno¶ci jest to, ¿e $E1$ i $E2$ musz± byæ tego samego typu, który te¿
jest typem ca³ego wyra¿enia. Je¿eli $P = {\it true}$ to jego warto¶ci± jest
$E1$, w przeciwnym przypadku $E2$.

\nowalinia
Przyk³ad - warto¶æ bezwzglêdna:

\begin{zed}
	abs = (\lambda x : \num @ \IF x < 0 \THEN -x \ELSE x)
\end{zed}

\section{Jêzyk schematyczny notacji i rachunek schematów}

Notacja \zet jest oparta na pojêciach matematycznych. Jêzyk matematyczny
dostarcza spójnych i precyzyjnych mechanizmów opisu, co pozwala na
zdefiniowanie mechanizmów systemu. Jednak¿e opis taki bez jasnej struktury
by³by trudno zrozumia³y, co uniemo¿liwia³oby stosowanie \zet jako jêzyka
specyfikacji. Problem ten rozwi±zuje jêzyk schematów \zet.

\subsection{Definicje typów bazowych}

Jest to zapis o postaci:

\begin{zed} [TYP1, \dots, TYPn] \end{zed}

Typy mog± byæ traktowane jako zbiory i w stosunku do nich maj± sens np.
operatory relacji lub zawierania. Jest to definicja wprowadzaj±ca nazwê typu
do specyfikacji, ale nie mówi±ca nic o jego w³a¶ciwo¶ciach. 

Definicje te (podobnie jak definicje aksjomatyczne i schematy) s± widoczne
globalnie w specyfikacji od momentu zdefiniowania.

\subsection{Aksjomaty}

Aksjomat umo¿liwia wyspecyfikowanie zmiennych oraz warunków,
jakie musz± spe³niaæ ich warto¶ci. Poprawna definicja sk³ada siê z
deklaracji i ew. predykatów; ma postaæ:

\begin{axdef}
	n : \num
\end{axdef}

lub

\begin{axdef}
	n : \num
\where
	n > 4
\end{axdef}

\subsection{Schematy}

Jest to podstawowy element notacji \zet. Podobnie jak aksjomat, sk³ada siê z
deklaracji i predykatów, ale jest nazwany, co pozwala odwo³ywaæ siê do niego
w innych czê¶ciach specyfikacji. Mo¿na tworzyæ nowe za pomoc± dzia³añ rachunku
schematów. Przyk³ad z punktu \ref{r:sam_rej}:

\begin{schema}{Rejestr}
	zarejestrowany: SAMOCHOD \pfun OSOBA
\where
	zarejestrowany \subseteq pozwolenie
\end{schema}

Dostêpna jest te¿ równowa¿na definicja:

\begin{zed}
Rejestr \defs \\
\t1	 [~ zarejestrowany: SAMOCHOD \pfun OSOBA | zarejestrowany \subseteq pozwolenie ~]
\end{zed}

Schemat jest z³o¿ony (podobnie jak aksjomat) z dwóch czê¶ci - deklaracji
(tzw. sygnatury) i predykatów. Pomijaj±c ich matematyczn± definicjê, mo¿emy
je przedstawiæ jako deklaracjê zmiennych wraz z opisem typu, oraz wyra¿enia
opisuj±ce mo¿liwe warto¶ci tych zmiennych (czyli predykaty). Kolejno¶æ
zmiennych nie jest okre¶lona - nie ma na nich okre¶lonej relacji porz±dku.
Je¿eli czê¶æ predykatu sk³ada siê z kilku wyra¿eñ w oddzielnych wierszach,
to domy¶lnie s± one po³±czone koniunkcj± $(P \iff P_1 \land \dots \land P_n)$. 

W definicji schematu mo¿na w³±czaæ referencje do innych schematów, np.

\begin{zed}
Urzad \defs [~ Rejestr; \dots | \dots ~]
\end{zed}

Do komponentów schematu mo¿na odwo³ywaæ siê poprzez mechanizm selekcji:

\begin{zed}
Rejestr.zarejestrowany \notin \emptyset
\end{zed}

We¼my schemat:

\begin{schema}{Punkt}
	x, y : \nat
\where
	x > 0 \land y > 0
\end{schema}

Notacja $\theta Punkt$ oznacza sygnaturê schematu - czyli $x, y$. Predykat
schematu okre¶la mo¿liwe warto¶ci, jakie mog± przyjmowaæ zadeklarowane
zmienne. Stosuj±c podej¶cie obiektowe, mo¿emy powiedzieæ ¿e jest to pewna
klasa obiektów reprezentuj±cych punkty. Aby opisaæ konkretny punkt - czyli
instancjê klasy, mo¿emy napisaæ wi±zanie \footnote{Nale¿y zwróciæ uwagê, ¿e
wi±zania nie s± czê¶ci± standardowej \zet notacji w rozumieniu {\bf ZRM}
\cite{Spivey-ZRM} - chocia¿ konstrukcja taka jest u¿ywana w tej ksi±¿ce.
Wi±zania s± natomiast czê¶ci± standardu \zet (p. \ref{r:iso_bindings}).
Narzêdzia wspomagaj±ce projektowanie \zet mog± zatem ró¿nie je traktowaæ.}
$\lblot x \bind 1, y \bind 1 \rblot$. Prawid³owe jest przypisanie
$\theta Punkt = \lblot x \bind 1, y \bind 1 \rblot$.

Deklaracja $a : S$ jest skrócon± form± zapisu $a : \{~S @ \theta S\}~ $. 

\subsection{Przemianowywanie i dekorowanie}\label{r:decorations}

Przemianowywanie (ang. {\it renaming}) polega na utworzeniu nowego schematu,
za pomoc± starej definicji. Maj±c schemat $S$, to zapis

\begin{zed}
S[~ y_1/x_1, \dots, y_n/x_n ~]
\end{zed}

tworzy nowy schemat, powsta³y przez zamianê ka¿dego komponentu $x_i$ na 
odpowiadaj±cy $y_i$. Aby to mia³o sens, odpowiadaj±ce sobie komponenty musz± 
byæ tego samego typu, poza tym nazwy $x_i$ nie mog± siê powtarzaæ ($y_i$ mog±).
Sygnatura powstaje przez podstawienie, a je¶li po tym oka¿e siê, ¿e wystêpuj± 
dwa komponenty o tej samej nazwie, to s± one ³±czone w jeden (pod warunkiem
¿e s± tego samego typu). Takie ³±czenie mo¿e zaj¶æ, gdy w schemacie $S$ 
znajduje siê komponent o tej samej nazwie co $y_i$, który nie uczestniczy 
w zamianie.

Dekorowanie jest operacj±, która pozwala na przemianowanie wszystkich 
komponentów schematu poprzez dodanie przyrostka. Przyk³adowo je¶li $S$
jest schematem, to $S'$ jest takim samym schematem, w którym nazwy 
komponentów maj± dodany przyrostek $'$. Je¶li sygnatura $S$ zawiera 
element $x$, to $S'$ zawiera $x'$.

Dekoracje maj± fundamentalne znaczenie w opisie systemów sekwencyjnych
(patrz \ref{r:seq_systems}). Standardowymi dekoracjami w \zet s± $'$ 
(które oznaczaj± stan po wykonaniu operacji), $?$ (które oznaczaj± 
wej¶cia operacji) oraz $!$ (wyj¶cia). Dopuszczalnymi dekoracjami 
s± te¿ indeksy (np. $x_1$), podwójne cudzys³owy ($x''$), lub kombinacje
($x?!$, $x'?$, $x_1!$).

\subsection{Rachunek schematów}\label{r:schema_calculus}

Schematy s± dobrze zdefiniowanymi elementami \zet notacji. Z ich w³a¶ciwo¶ci
wynika, ¿e mo¿na na nich przeprowadzaæ ró¿ne dzia³ania, takie jak z³o¿enie,
albo aplikowanie standardowych operatorów logicznych, tworz±c w ten sposób
nowe schematy. Ma to zasadnicze znaczenie praktyczne i pozwala na ³atwe
dzielenie specyfikacji na bloki, które potem mo¿na sk³adaæ ze sob±.

\subsubsection{Operatory logiczne}

Wspomniano ju¿, ¿e schematy sk³adaj± siê z sygnatury oraz predykatu.
Sygnatury mo¿na ³±czyæ ze sob±, pod warunkiem ¿e s± {\it kompatybilne pod
wzglêdem typów}, tzn. ¿e je¶li wystêpuj± w nich deklaracje tych samych
zmiennych, to musz± byæ tego samego typu. Ilustruje to przyk³ad dwóch
sygnatur:

\begin{zed}
a \in \power X; b \in X \cross Y
\end{zed}

i

\begin{zed}
b \in X \cross Y; c \in Z
\end{zed}

S± one {\it kompatybilne pod wzglêdem typów}, poniewa¿ typ wspólnej zmiennej
$b$ jest jednakowy dla obu sygnatur. Zatem ich po³±czenie to:

\begin{zed}
a \in \power X; b \in X \cross Y; c \in Z
\end{zed}

Zatem, maj±c dwa schematy spe³niaj±ce powy¿sz± definicjê, mo¿emy zdefiniowaæ 
operacje logiczne. We¼my:

\begin{schema}{S1}
	a : A \\
	b : B
\where
	P1
\end{schema}

i 

\begin{schema}{S2}
	b : B \\
	c : C
\where
	P2
\end{schema}

Negacja schematu $\lnot S1$ okre¶lona jest nastêpuj±co (uwaga: schematy
nienazwane nie s± czê¶ci± standardowej notacji):

\begin{schema*}
	a : A \\
	b : B
\where
	\lnot P1
\end{schema*}

Koniunkcja:

\begin{schema*}
	a : A \\
	b : B \\
	c : C
\where
	P1 \land P2
\end{schema*}

W taki sam sposób zdefiniowaæ mo¿na alternatywê schematów ($\lor$),
implikacjê ($\implies$) i równowa¿no¶æ ($\iff$).

\subsubsection{Kwantyfikacja}

Nowy schemat mo¿emy równie¿ utworzyæ poprzez zastosowanie kwantyfikacji po
wybranych elementach. Je¶li $D$ jest deklaracj±, $P$ predykatem a $S$ schematem, to

\begin{zed}
	\forall D | P @ S
\end{zed}

równie¿ jest schematem. Sygnatura zawiera wszystkie komponenty schematu $S$
z wyj±tkiem tych, które znajduj± siê równie¿ w $D$. Rezultat mo¿na opisaæ
nastêpuj±co: dla ka¿dego wi±zania $z$ rezultatu we¼ wszystkie rozszerzenia
$z'$ do sygnatury $S$. Je¿eli dla ka¿dego wi±zania $z'$, które spe³nia
warunki $S$ spe³nione s± jednocze¶nie warunki $D$ i predykat $P$, to wtedy
oryginalne wi±zanie $z$ spe³nia warunki $\forall D | P @ S$.

Maj±c

\begin{schema}{Tabliczka}
	x : 0 \upto 9 \\
	y : \num 
\where
	y = x * x
\end{schema}

to schemat $\forall x : \num | x > 5 @ Tabliczka$ jest okre¶lony
nastêpuj±co:

\begin{schema*}
	y : \num 
\where
	\forall x : \num | x > 5 @ x \in 0 \upto 9 \land y = x * x
\end{schema*}

Nale¿y zauwa¿yæ, ¿e element $x$ przeszed³ z sygnatury do predykatu.

Podobne dzia³ania mo¿emy wykonaæ z u¿yciem kwantyfikatorów $\exists$ i
$\exists_1$ \footnote{$\exists_1$ oznacza `istnieje dok³adnie jeden'}.

\subsubsection{Ukrywanie}\label{r:hiding}

Ukrywanie (ang. {\it hiding}) nosi te¿ nazwê egzystencjalnej kwantyfikacji.
Pozwala on na pozbywanie siê elementów z czê¶ci deklaracyjnej schematu
(podobnie jak kwantyfikowanie opisane w poprzednim punkcie).
Zapis ten ma postaæ

\begin{zed}
S \hide (x_1, \dots, x_n)
\end{zed}

i jest równowa¿ny do

\begin{zed}
	(\exists x_1 : t_1; \dots; x_n : t_n @ S)
\end{zed}

gdzie $x_1 \dots x_n$ s± typu $t_1 \dots t_n$ w $S$.

Maj±c deklaracjê $Tabliczka$, schemat $Tabliczka \hide (x)$ jest okre¶lony:

\begin{schema*}
	y : \num
\where
	\exists x : 0 \upto 9 @ y = x * x
\end{schema*}

Mo¿na ukryæ wszystkie komponenty schematu. Rezultatem jest schemat z pust±
sygnatur± i predykatem, który ma warto¶æ {\it true} lub {\it false} dla
unikalnego pustego wi±zania $\lblot \rblot$, zale¿nie od tego czy istniej±
wi±zania spe³niaj±ce warunki oryginalnego schematu.

\subsubsection{Projekcja}

Projekcja jest rozszerzeniem ukrywania. Operator projekcji $S \project T$
ukrywa wszystkie elementy z $S$, które tak¿e wystêpuj± w $T$. $S, T$ musz±
byæ {\it kompatybilne pod wzglêdem typów}. Wyra¿enie $S \project T$ jest
równowa¿ne do

\begin{zed}
(S \land T) \hide (x_1, \dots, x_n)
\end{zed}

gdzie $(x_1, \dots, x_n)$ s± wszystkimi komponentami $S$, których nie ma w $T$.

\section{Systemy sekwencyjne}\label{r:seq_systems}

Schematy pozwalaj± na opisanie zarówno statycznych, jak i dynamicznych
aspektów systemu. Czê¶æ statyczna obejmuje:

\begin{itemize}
\item{} mo¿liwe stany systemu
\item{} relacje, które s± zachowywane podczas przechodzenia systemu ze stanu
do stanu
\end{itemize}

W tej definicji mieszcz± siê równie¿ deklaracje podstawowych typów, struktur
danych, u¿ywanych zmiennych i zasobów. Modelowanie komponentów systemu
równie¿ ma charakter statyczny o ile nie opisujemy interakcji pomiêdzy nimi
(co najwy¿ej wspólne zasoby). Charakterystyka zachowañ systemu oddawana jest
przez czê¶æ dynamiczn±:

\begin{itemize}
\item{} operacje na systemie
\item{} mo¿liwe zmiany stanu
\item{} relacje pomiêdzy wej¶ciem a wyj¶ciem stanów
\end{itemize}

Za pomoc± dynamicznych elementów notacji mo¿emy opisaæ interakcje pomiêdzy
komponentami systemu w sposób formalny i w³a¶nie to stanowi o najwiêkszej
zalecie projektowania z u¿yciem notacji \zet. Zapisy te nie s± ju¿ sekwencj±
instrukcji, któr± trudno analizowaæ, ale zbiorem za³o¿eñ i twierdzeñ
dotycz±cych dzia³ania oprogramowania w formie schematów. Takie podej¶cie
umo¿liwia stosowanie logiki i rachunku predykatów, dziêki czemu projektant
mo¿e udowodniæ s³uszno¶æ specyfikacji, wykazuj±c ¿e nie zachodzi sprzeczno¶æ
pomiêdzy poszczególnymi czê¶ciami projektu i ¿e ca³o¶æ jest spójna w sensie
formalnym. 

\subsection{Przestrzeñ stanów}

We¼my schemat postaci:

\begin{schema}{StateSpace}
	x_1 : S_1; \dots; x_n : S_n
\where
	Inv(x_1, \dots, x_n)
\end{schema}

Schemat ten definiuje pewn± przestrzeñ stanów. $x_1, \dots, x_n$ to s±
zmienne stanu, natomiast $Inv(x_1, \dots, x_n)$ jest {\it niezmiennikiem}
stanu, tj. predykatem zawieraj±cym zmienne $x_1, \dots, x_n$, zawsze 
spe³nionym przez mo¿liwe wi±zania schematu, niezale¿nie od operacji 
przeprowadzanych w systemie.

Klasyczny przyk³ad z referencji Spivey'a \cite{Spivey-ZRM}:

\begin{schema}{BirthdayBook} 
	known : \power NAME \\
	birthday : NAME \pfun DATE
\where
	known = \dom birthday
\end{schema}

Niezmiennikiem jest fakt, ¿e ka¿da znana osoba posiada datê urodzenia.

\subsection{Operacje}

Do zdefiniowania operacji wykorzystuje siê dekorowanie (p.
\ref{r:decorations}). Przyjmuje siê, ¿e schemat $S$ opisuje stan systemu
przed wykonaniem operacji, natomiast $S'$ - po. Rozwa¿my $StateSpace$ z
poprzedniego punktu, wtedy $StateSpace'$:

\begin{schema}{StateSpace'}
	x_1' : S_1; \dots; x_n' : S_n
\where
	Inv(x_1', \dots, x_n')
\end{schema}

wyra¿a przestrzeñ stanów po wykonaniu operacji. Wystarczy teraz po³±czyæ je
ze sob±, aby otrzymaæ definicjê operacji:

\begin{schema}{Operation}
	StateSpace \\
	StateSpace' 
\where
	\dots
\end{schema}

lub po rozwiniêciu:

\begin{schema}{Operation}
	x_1 : S_1; \dots; x_n : S_n \\
	x_1' : S_1; \dots; x_n' : S_n
\where
	Inv(x_1, \dots, x_n) \\
	Inv(x_1', \dots, x_n')
\end{schema}

Aby skróciæ ten zapis, u¿ywamy notacji $\Delta$:

\begin{schema}{\Delta StateSpace}
	StateSpace \\
	StateSpace'
\end{schema}

Umieszczenie $\Delta StateSpace$ w czê¶ci deklaracyjnej oznacza w³±czenie
dwóch kopii tego schematu w celu opisania systemu sekwencyjnego.

Operacjê zmiany stanów mo¿na rozszerzyæ o w³±czenie deklaracji wej¶æ i wyj¶æ
(ang. {\it inputs, outputs}). Otrzymuje siê je równie¿ poprzez dekorowanie,
tym razem z u¿yciem symboli odpowiednio $?$ i $!$.  Wersja rozszerzona
wygl±da teraz tak:

\begin{schema}{Operation}\label{r:operations}
	x_1 : S_1; \dots; x_n : S_n \\
	x_1' : S_1; \dots; x_n' : S_n \\
	i_1? : TI_1; \dots; i_m? : TI_m \\
	o_1! : TO_1; \dots; o_p! : TO_p
\where
	Inv(x_1, \dots, x_n) \\
	Inv(x_1', \dots, x_n') \\
	Pre(i_1?, \dots, i_m?, x_1, \dots, x_n) \\
	Op(i_1?, \dots, i_m?, x_1, \dots, x_n, x_1', \dots, x_n', o_1!, \dots, o_p!)
\end{schema}

lub krócej

\begin{schema}{Operation}
	\Delta StateSpace \\
	i_1? : TI_1; \dots; i_m? : TI_m \\
	o_1! : TO_1; \dots; o_p! : TO_p
\where
	Pre(i_1?, \dots, i_m?, x_1, \dots, x_n) \\
	Op(i_1?, \dots, i_m?, x_1, \dots, x_n, x_1', \dots, x_n', o_1!, \dots, o_p!)
\end{schema}

$(i_1?, \dots, i_m?)$ to s± wej¶cia operacji, $(o_1!, \dots, o_p!)$ - wyj¶cia.

Warunkami wstêpnymi operacji s± predykaty zawieraj±ce zmienne wej¶æ operacji
$i_1?, \dots, i_m?$ oraz zmienne stanu $x_1, \dots, x_n$, co ilustruje
wyra¿enie $Pre(i_1?, \dots, i_m?, x_1, \dots, x_n)$. 

Warunki wstêpne operacji s± wa¿ne z punktu widzenia badania poprawno¶ci
systemu (patrz p. \ref{r:proving}). Notacja \zet wprowadza zapis 
$\pre Operation$, który jest schematem okre¶lonym nastêpuj±co:

\begin{zed}
	\exists StateSpace'; o_1! : TO_1; \dots; o_p! : TO_p @ Operation
\end{zed}

Warunki wstêpne s± okre¶lone przez predykat $P$, je¿eli spe³nione jest

\begin{zed}
	\forall StateSpace; in? : IN | P @ \pre Operation
\end{zed}

Operacje nie musz± wi±zaæ siê ze zmian± stanu. W tym celu jêzyk schematów \zet
wprowadza nastêpny zapis, $\Xi StateSpace$, okre¶lony jako

\begin{schema}{\Xi StateSpace}
	StateSpace \\
	StateSpace'
\where
	\theta StateSpace = \theta StateSpace'
\end{schema}

czyli

\begin{zed}
	\Xi StateSpace \defs [~ \Delta StateSpace | \theta StateSpace' = \theta StateSpace ~]
\end{zed}

\subsection{Stan pocz±tkowy}\label{r:init_state}

W systemie sekwencyjnym, oprócz zdefiniowania przestrzeni stanów oraz operacji
przej¶cia pomiêdzy nimi, potrzebna jest te¿ informacja o stanie pocz±tkowym.

Mo¿e ona byæ zdefiniowana nastêpuj±co:

\begin{schema}{Init}
	StateSpace'
\where
	Op(x_1', \dots, x_n')
\end{schema}

Warunkiem poprawno¶ci takiej operacji jest

\begin{zed}
	\exists StateSpace' @ Init
\end{zed}

Kompletny dowód poprawno¶ci specyfikacji zawiera zarówno teorematy potrzebne
do stwierdzenia, czy opisane operacje s± mo¿liwe do przeprowadzenia na danej
przestrzeni stanów, jak równie¿ dowód osi±galno¶ci stanu pocz±tkowego.

\subsection{Operator z³o¿enia sekwencyjnego}\label{r:semi_operator}

Z³o¿enie jest sposobem opisania dwóch nastêpuj±cych po sobie operacji. Maj±c
operacje $S$ i $T$, ich z³o¿enie $S \semi T$ to schemat zawieraj±cy wszystkie 
komponenty $S$ i $T$ z wyj±tkiem $x'$ schematu $S$ i $x$ schematu $T$, gdzie $x$
jest odpowiedni± zmienn± stanu. Jest on okre¶lony:

\begin{zed}
\exists State'' @ \\
\t1	(\exists State' @ [S; State'' | \theta State' = \theta State'']) \land \\
\t1	(\exists State @ [T; State'' | \theta State = \theta State''])
\end{zed}

$State''$ jest ukrytym stanem, na którym koñczy $S$, a zaczyna siê $T$.

Np. maj±c operacje:

\begin{schema}{Op1}
	a, a' : A
	b, b' : B
\where
	P
\end{schema}

i

\begin{schema}{Op2}
	a, a' : A
	b, b' : B
\where
	P
\end{schema}

ich z³o¿enie to

\begin{zed}
Op1 \semi Op2 = \\
\t1	(Op1[~ a''/a', b''/b' ~] \land Op2[~ a''/a, b''/b ~]) \hide (a'', b'')
\end{zed}

co daje nastêpuj±cy schemat:

\begin{schema*}
	a, a' : A \\
	b, b' : B
\where
	\exists a'', b'' @ \\
\t1		P[~ a''/a', b''/b' ~] \land Q[~ a''/a, b''/b ~]
\end{schema*}

Nale¿y podkre¶liæ, ¿e taka definicja sekwencji operacji ró¿ni siê od tego,
co znamy z jêzyków programowania. Wystarczy bowiem by istnia³ {\it
jakikolwiek} stan koñcowy operacji $Op1$, który spe³nia warunki wstêpne
operacji $Op2$. W rzeczywistym programie zazwyczaj ka¿dy stan, w jakim
koñczy siê operacja $Op1$ musi spe³niaæ warunki wstêpne $Op2$. Taki warunek
poprawno¶ci, który nak³ada to ograniczenie w celu zagwarantowania poprawnej
implementacji $Op1; Op2$ z³o¿enia $Op1 \semi Op2$ mo¿na zapisaæ:

\begin{zed}
\forall State'' @ \\
\t1	(\exists Op1 @ \theta State' = \theta State'') \\
\t1	\implies (\exists Op2 @ \theta State = \theta State'')
\end{zed}

Oznacza to, ¿e jakikolwiek stan, w jakim koñczy siê operacja  $Op1$, spe³nia
warunki wstêpne operacji $Op2$. Oczywi¶cie warunkiem poprawno¶ci z³o¿enia
jest te¿ fakt, ¿e obie operacje s± okre¶lone na komponentach tego samego
typu.


\subsection{Operator potoku}

Operator potoku jest u¿ywany do po³±czenia dwóch operacji, które s±
niezale¿ne od siebie - tzn. s± okre¶lone na innych danych i nie musz±
(chocia¿ mog±) mieæ wspó³dzielonych komponentów. W $Op1 \pipe Op2$ wyj¶cia
operacji $Op1$ (oznaczone przez $!$) s± podawane na wej¶cie operacji $Op2$
(czyli komponenty dekorowane przez $?$). W nowym schemacie komponenty 
uczestnicz±ce w ³±czeniu s± ukrywane, natomiast pozosta³e s± ³±czone tak jak 
dla koniunkcji $Op1 \land Op2$.

Maj±c schemat

\begin{schema}{Wplata}
	\Delta Konto \\
	kwota? : \nat \\
	nowe\_saldo! : \nat
\where
	saldo' = saldo + kwota? \\
	limit' = limit \\
	nowe\_saldo! = saldo'
\end{schema}

oraz operacjê bez zmiennych stanu

\begin{schema}{Podwojenie}
	x?, y! : \nat
\where
	y! = x? + x?
\end{schema}

mo¿emy zapisaæ

\begin{zed}
	WplataPodwojna \defs Podwojenie \pipe Wplata[~ y? / kwota? ~] 
\end{zed}

Stosuj±c dekorowanie przyporz±dkowujemy w³a¶ciwe wyj¶cia $Podwojenie$ do
odpowiednich danych wej¶ciowych operacji $Wplata$. Otrzymujemy wtedy schemat:
 
\begin{schema}{WplataPodwojna}
	\Delta Konto \\
	x? : \nat \\
	nowe\_saldo! : \nat
\where
	saldo' = saldo + x? + x? \\
	limit' = limit \\
	nowe\_saldo! = saldo'  
\end{schema}

\section{Zaawansowane elementy notacji}

\subsection{Definicje uogólnione}\label{r:generic_definitions}

Definicje uogólnione (ang. {\it generic definitions}) wzbogacaj± \zet o
mo¿liwo¶æ szablonowego specyfikowania elementów specyfikacji, które siê
powtarzaj± i s± niezale¿ne od pozosta³ych. Ma to swoje odbicie w
rzeczywistych systemach komputerowych, w których czêsto wystêpuj± sk³adowe
elementy o analogicznych w³a¶ciwo¶ciach. Przyk³adowo mo¿emy za pomoc± tych
definicji opisaæ system zarz±dzania zasobami, niezale¿nie od ich typu
(pliki, bloki pamiêci, komputery w klastrze). W ten sposób da siê równie¿
opisaæ funkcjê spe³niaj±c± okre¶lone za³o¿enia (np. funkcjê haszuj±c±) -
niezale¿nie od zbiorów, na których operuje.

Pojêcie definicji uogólnionych nasuwa skojarzenia z szablonami {\it (ang.
templates)}, znanymi z jêzyka programowania C++, choæ oczywi¶cie s± to
odmienne pojêcia. Pozwalaj± one na dalsz± strukturalizacjê i uproszczenie
specyfikacji.

Definicja uogólniona ma postaæ:

\begin{gendef}[X_1, \dots, X_n]
	D
\where
	P
\end{gendef}

Identyfikatory $X_i$ mog± byæ u¿ywane w czê¶ci deklaracyjnej, jak i w
predykacie. Oczywi¶cie definicjê tak± mo¿na nazwaæ, otrzymuj±c wtedy
uogólniony schemat:

\begin{schema}{GenericSchema}[X_1, \dots, X_n]
	D
\where
	P
\end{schema}

Z tak zdefiniowanego schematu mo¿na korzystaæ tak samo jak ze zwyk³ego
schematu, pod warunkiem ¿e odwo³uj±c siê do niego podamy warto¶ci dla
identyfikatorów $X_i$, np. $S[\num, \power \nat]$ \footnote{w \zet dostêpny
jest mechanizm automatycznej asercji w³a¶ciwych warto¶ci, co pozwala na
unikniêcie ich podawania. Regu³y na to podane s± w ksi±¿ce Spivey'a
\cite{Spivey-ZRM}, okre¶lone te¿ s± w standardzie ISO \cite{ISO}. Praktyka
pokazuje jednak, ¿e jest to niebezpieczne, szczególnie mo¿e sprawiaæ k³opoty
podczas dowodzenia poprawno¶ci.}.

Mo¿liwe jest pominiêcie notacji schematycznej \zet i stosowanie zwyk³ych
wyra¿eñ, dopuszczonych przez sk³adniê notacji i widocznych globalnie.
Przyk³ad: relacja czê¶ciowego porz±dku:

\begin{zed}
partial\_order[~ X ]~ == \\
\t1	\{~ \_ \underline{R} \_ : X \rel X | (\forall x,y,z : X @ \\
\t2		x \underline{R} x \land \\
\t2		(x \underline{R} y \land y \underline{R} x) \implies x = y \land \\
\t2		(x \underline{R} y \land y \underline{R} z) \implies x \underline{R} z)\}~
\end{zed}

Relacja porz±dku:

\begin{zed}
total\_order[~ X ]~ == \\
\t1	\{~ \_ \underline{R} \_ : partial\_order[~ X ]~ | \\
\t2		(\forall x,y : X @ x \underline{R} y \lor y \underline{R} x)\}~
\end{zed}

Oczywi¶cie dowód przeprowadzony na definicji uogólnionej, jest równie¿ 
uogólniony, co skraca te¿ proces dowodzenia poprawno¶ci.

\subsection{Typy wolne}\label{r:free_types}

Notacja dla definicji typów wolnych zosta³a stworzona, aby u³atwiæ zapis struktur 
rekursywnych, takich jak listy i drzewa. W/g \cite{Spivey-ZRM} sk³adnia 
definicji typu wolnego wygl±da nastêpuj±co:

\begin{zed}
Paragraph \t1	::=	Ident ::= Branch | \dots | Branch \\
Branch \t1	::=	Ident [ \langle\langle Expression \rangle\rangle ]
\end{zed}

Definicja

\begin{zed}
T ::= c_1 | \dots | c_m | d_1 \langle\langle E_1[T] \rangle\rangle 
	| \dots | d_n \langle\langle E_n[T] \rangle\rangle 
\end{zed}

definiuje nowy typ podstawowy $T$, oraz $m + n$ zmiennych $c_1, \dots, c_m$ i
$d_1, \dots, d_n$, co jest równowa¿ne deklaracji:

\begin{axdef}
	c_1, \dots, c_m : T \\
	d_1 : E_1[T] \pinj T \\
	. \\
	. \\
	. \\
	d_n : E_n[T] \pinj T
\where
	\mbox{\dots patrz nizej \dots}
\end{axdef}

Zmienne $c_i$ s± sta³ymi typu $T$, natomiast $d_j$ nazywane s± konstruktorami
i s± injekcjami ze zbiorów $E_j[T]$ na $T$. W wyra¿eniach $E_j[T]$
mog± znajdowaæ siê deklaracje typu $T$, co pozwala na definicje rekursywne.

Aby definicja typu wolnego nie by³a cykliczna, sta³e $c_i$ wystêpuj± przed 
zmiennymi $d_j$, co powoduje, ¿e typ $T$ jest ju¿ zadeklarowany jako typ
podstawowy, zanim nastêpuje deklaracja wyra¿eñ $d_j$.

Poprawno¶æ definicji warunkuje spe³nienie dwóch aksjomatów. Pierwszy mówi,
¿e zarówno sta³e $c_i$ musz± byæ ro¿ne, jak równie¿ zakresy zbiorów
warto¶ci konstruktorów musz± byæ roz³±czne. Opisuje to:

\begin{zed}
	\disjoint \langle \{c_1\}, \dots, \{c_m\}, \ran d_1, \dots, \ran d_n \rangle
\end{zed}

Po drugie najmniejszy podzbiór $T$, który zawiera wszystkie sta³e i jest
zamkniêty pod konstruktorami, to
jest $T$ \footnote{Zbiór jest zamkniêty pod konstruktorami je¶li
zastosowanie któregokolwiek z nich na jakim¶ elemencie zbioru generuje
jedynie inny element z tego zbioru}. Opisuje to regu³a indukcyjna:

\begin{zed}
\forall W: \power T @ \\
\t1		\{ c_1, \dots, c_m \} \cup d_1 \limg E_1[W] \rimg \cup \dots
			\cup d_n \limg E_n[W] \rimg \subseteq W \\
\t1		\implies T = W
\end{zed}

$E_j[T]$ to wyra¿enie, które powstaje jako rezultat zamiany wszystkich wolnych 
wyst±pieñ $T$ w $E_j[T]$ na $W$. Je¿eli konstruktory $E_j$ s± skoñczone,
wtedy ta regu³a indukcyjna implikuje, ¿e sta³e i konstruktory razem pokrywaj±
ca³y zbiór $T$, wiêc

\begin{zed}
	\langle \{c_1\}, \dots, \{c_m\}, \ran d_1, \dots, \ran d_n \rangle \partition T
\end{zed}

\paragraph{Przyk³ad 1}

Najprostszym przyk³adem definicji typu wolnego jest przypadek, gdy wystêpuj± tylko
sta³e, czyli konstruktory bez argumentów.

\begin{zed}
	BARWY ::= CZERWONA | ZIELONA | NIEBIESKA
\end{zed}

W/g powy¿szego, definicja ta jest równowa¿na do:

\begin{axdef}
	[BARWY]	
\end{axdef}

\begin{axdef}
	CZERWONA, ZIELONA, NIEBIESKA : BARWY	
\where
	\disjoint \langle \{CZERWONA\}, \{ZIELONA\}, \{NIEBIESKA\} \rangle \land \\
	\forall W : \power BARWY @ \\
\t1		\{ CZERWONA, ZIELONA, NIEBIESKA \} \subseteq W \implies
			BARWY = W
\end{axdef}

\paragraph{Przyk³ad 2}

Klasycznym przyk³adem typu wolnego jest zbiór drzew binarnych oznaczonych liczbami
naturalnymi.

\begin{zed}
	TREE ::= tip | fork\langle\langle \nat \cross TREE \cross TREE \rangle\rangle
\end{zed}

Sta³a $tip$ jest pustym drzewem, a je¶li $n$ to liczba, a $t_1$ i $t_2$ to
drzewa, zatem $fork(n, t1, t2)$ to równie¿ jest drzewo. Definicja ta
jest równowa¿na do:

\begin{zed}
	[TREE]
\end{zed}

\begin{axdef}
	tip : TREE \\
	fork : \nat \cross TREE \cross TREE \pinj TREE
\where
	\disjoint \langle \{tip\}, \ran fork \rangle \\
	\\
	\forall W : \power TREE @ \\
\t1		\{tip\} \cup fork \limg \nat \cross W \cross W \rimg \subseteq W \\
\t1		\implies TREE = W
\end{axdef}

Konstruktor $fork$ jest injekcj±, a zatem daj±c mu jako argument dwa ró¿ne drzewa, lub
drzewa oznaczone innym numerem, otrzymujemy ró¿ne rezultaty.  Zakres $fork$ jest roz³±czny ze
zbiorem $\{tip\}$:

\begin{zed}
	tip \notin \ran fork
\end{zed}

wiêc $tip$ nie mo¿e byæ rezultatem konstruktora $fork$.

W³a¶ciwo¶ci typów wolnych mo¿na dowodziæ za pomoc± indukcji i podanej regu³y indukcyjnej.

\section{Przyk³ady zastosowañ \zet}

\subsection{Przetwarzanie tekstu}

W przyk³adzie tym chcia³bym przedstawiæ model \zet, podany za \cite{Jacky}, 
pokazuj±cy specyfikacjê programów s³u¿±cych do przetwarzania
tekstu. Analogiczne specyfikacje mo¿na równie¿ znale¼æ w \cite{Bowen}.

\subsubsection{Dzielenie tekstu na s³owa}

Zacznê od zdefiniowania zbioru znaków. Tekst jest sekwencj± znaków. Niektóre
znaki s± znakami `pustymi' (spacje, tabulatory, koñce linii). Odstêp jest
sekwencj± takich znaków, natomiast s³owo jest sekwencj±, która ich nie
zawiera. S³owa mog± byæ oddzielone odstêpem.

\begin{zed} [ZNAK] \end{zed}
\begin{axdef} pusty: \power ZNAK \end{axdef}
\begin{zed}
        TEKST == \seq ZNAK
\also
	ODSTEP == \seq_1 pusty \\
\also
	SLOWO == \seq_1 (ZNAK \setminus pusty)
\end{zed}

$TEKST$ mo¿e byæ ci±giem pustym, ale $ODSTEP$ and $SLOWO$ musz± mieæ
co najmniej jeden znak, zatem deklarujemy je jako $\seq_1$ (niepuste
sekwencje).

Przedstawiane programy do zliczania i formatowania bazuj± na funkcji $slowa$.
Funkcja ta zwraca sekwencjê wszystkich s³ów w tek¶cie. Przyk³adowo:

\begin{zed}
slowa~\langle A,l,a,~,m,a,~,k,o,t,k,a \rangle = \langle \langle A,l,a \rangle , \langle m,a \rangle , \langle k,o,t,k,a \rangle \rangle
\end{zed}

Zatem $words$ to funkcja $TEKST$ do sekwencji $SLOWO$.
Aby j± zdefiniowaæ, okre¶lê wszystkie mo¿liwe wzorce s³ów oraz odstêpów,
dla ka¿dej z nich pisz±c równanie.

\begin{axdef}
        slowa: TEKST \fun \seq SLOWO
\where 
        \forall o: ODSTEP; s: SLOWO; l,p: TEKST  @ \\
\t1		slowa~ \langle \rangle = \langle \rangle \land \\
\t1		slowa~ o = \langle \rangle \land \\
\t1		slowa~ s = \langle s \rangle \land \\
\t1		slowa~(o \cat p) = slowa~p \land \\
\t1		slowa~(l \cat o) = slowa~l \land \\
\t1		slowa~(l \cat o \cat p) = (slowa~l) \cat (slowa~p)
\end{axdef}

Jak widaæ wzorców tych nie jest zbyt wiele. Kiedy tekst jest pusty lub jest
odstêpem, rezultat równie¿ jest pusty.  Kiedy tekst sk³ada siê z jednego
s³owa, wynikiem jest to s³owo. Kiedy tekst zaczyna siê lub koñczy odstêpami,
mo¿na je wyci±æ. Kiedy z³o¿enie tekstu zawiera odstêp, mo¿na go podzieliæ na
dwa, ignoruj±c odstêp.

Ten przyk³ad ilustruje techniki \zet, które potrafi± sprawiæ, ¿e definicje s±
krótsze i bardziej przejrzyste ni¿ kod. Funkcja sk³ada siê z wyra¿eñ, które
ukrywaj± wewnêtrzn± strukturê argumentów. Definicja jest rekursywna.
Ostatnie wyra¿enie jest niedeterministyczne - nie ustala pocz±tku ani koñca
tekstu. Zatem tekst mo¿e byæ skanowany od pocz±tku do koñca tekstu, albo
odwrotnie, nie okre¶lamy tego pozwalaj±c uczyniæ to programi¶cie.

\subsubsection{Zliczanie s³ów}

Liczba s³ów w tek¶cie  $t$ to $\# (slowa~t)$. Mo¿na zdefiniowaæ funkcjê
podobn± do $slowa$, która dzieli tekst na linie. Zak³adam, ¿e koniec linii
wyznaczany jest specjalnym znakiem pustym $nl$.

%%\begin{axdef} nl: pusty \end{axdef}
%%\begin{zed} LINIA == \seq_1 (ZNAK \setminus \{ nl \}) \end{zed}
%%\begin{axdef} linie: TEKST \fun \seq LINIA \end{axdef}
%%unchecked
\begin{axdef}
        linie: TEKST \fun \seq LINIA
\where 
	\dots \mbox{definicja pominiêta} \dots
\end{axdef} 
Teraz jest wszystko co trzeba, aby napisaæ formaln± specyfikacjê dla
Unixowego polecenia $wc$. To popularne narzêdzie to w³a¶ciwie funkcja,
której argumentem jest nazwa pliku, a wynikiem trójka liczb: liczba linii,
s³ów oraz znaków w pliku. Typowe wywo³anie:

\[
\mbox{{\tt \% wc struktura.tex}}\\
\mbox{{\tt 110 559 4509}}
\]
Oto definicja $wc$:

\begin{axdef}
	wc: TEKST \fun (\nat \cross \nat \cross \nat)
\where
	\forall plik: TEKST @ \\
\t1		wc~plik = (\# (linie~plik), \# (slowa~plik), \# plik)
\end{axdef}
Lub krócej

\begin{zed}
   wc == (\lambda plik: TEKST @ (\# (linie~plik), \# (slowa~plik), \# plik))
\end{zed}

\subsubsection{Wype³nianie paragrafów}

Prawie ka¿dy edytor tekstu zapewnia operacjê {\em wype³nienie}. Operacja ta
zamienia nieuporz±dkowany tekst z liniami o ró¿nej d³ugo¶ci w sformatowany
tekst, którego wszystkie linie maj± prawie tê sam± d³ugo¶æ.

Zdefiniujmy operacjê wype³nienia w \zet. Mo¿na zauwa¿yæ, ¿e wype³nienia to
przyk³ad operacji formatowania tekstu, który zmienia jego wygl±d poprzez
³amanie linii w ró¿nych miejscach, oraz poszerzaj±c odstêpy pomiêdzy
s³owami, zak³adaj±c ¿e linie nie wychodz± poza obszar strony. Co wiêcej,
operacja formatowania nie mo¿e zmieniæ zawarto¶ci tekstu: zachowuje te same
s³owa w oryginalnej kolejno¶ci.

\begin{axdef} szerokosc: \nat \end{axdef}
\begin{schema}{Format}
	t,t': TEKST
\where
	slowa~t' = slowa~t \\
	\forall l: \ran~(linie~t') @ \# l \leq szerokosc
\end{schema} 
Operacja wype³nienia to operacja, która spe³nia dodatkowy warunek - linie
powinny byæ wype³nione jak tylko jest to mo¿liwe. Jest wiele ró¿nych metod
aby to zapewniæ, chyba najprostsz± zasad± jest wymaganie, ¿e wype³niony
tekst zawiera jak najmniej linii.

\begin{schema}{Wypelnienie}
	Format
\where
	\# (linie~t') = min~ \{ t': TEKST | Format @ \# (linie~t') \}
\end{schema}
Ta definicja mówi, ¿e $Wypelnienie$ jest operacj± {\em minimalizacji}, jest
to specjalizacja $Format$, która minimalizuje liczbê linii w tek¶cie. 
Funkcja $Format$ w definicji $Wypelnienie$ u¿yta jest jako predykat.

Definicja ta jest niedeterministyczna, jest zwykle wiele dróg do tego, aby
zapewniæ tê sam± najmniejsz± liczbê linii. 

\subsection{System rejestracji samochodów}\label{r:sam_rej}

Chcia³bym przedstawiæ model \zet systemu rejestracji samochodów. Osoby mog±
zarejestrowaæ samochód pod warunkiem posiadania sprawnego przegl±du
technicznego. Nie mo¿e zostaæ wydana rejestracja, je¶li samochód nie posiada
wa¿nego przegl±du. Ten sam samochód nie mo¿e zostaæ zarejestrowany przez
dwie osoby, mo¿e byæ jednak niezarejestrowany. Zdefiniujê zatem procedurê
rejestracji samochodu.

Oto model \zet. Najpierw wprowadziæ trzeba zbiory, które zawieraj± wszystkie
dane potrzebne w naszym systemie. Zbiory te oprócz samochodów i w³a¶cicieli
okre¶laj± bazê przegl±dów.

\begin{zed} [OSOBA, SAMOCHOD, PRZEGLAD] \end{zed}

Nastêpnie wyspecyfikowaæ trzeba relacje u¿yteczne do procesu rejestracji.

Pierwsza ³±czy samochody z w³a¶cicielami. Osoba jest w relacji z samochodem,
je¶li jest jego w³a¶cicielem.
\begin{axdef}
	pozwolenie: SAMOCHOD \rel OSOBA
\end{axdef}

Druga mówi o zwi±zku samochodu z przegl±dem.
\begin{axdef}
	sprawnosc: SAMOCHOD \rel PRZEGLAD
\end{axdef}

Stan systemu jest relacj± tego samego typu co $pozwolenie$, co okre¶la na
kogo zarejestrowany jest dany samochód. Wymaganiem jest, ¿e samochód mo¿e
nale¿eæ tylko do jednej osoby, zatem w tym przypadku mamy do czynienia z
funkcj±.

\begin{schema}{Rejestr}
	zarejestrowany: SAMOCHOD \pfun OSOBA
\where
	zarejestrowany \subseteq pozwolenie
\end{schema}

Trzeba zauwa¿yæ, ¿e $zarejestrowany$ jest czê¶ciow± funkcj±, co oznacza ¿e
niektóre samochody mog± nie byæ zarejestrowane na nikogo. Predykat mówi o
konieczno¶ci bycia w³a¶cicielem samochodu.

Formalna specyfikacja bazy przegl±dów:

\begin{schema}{Przeglady}
	zatwierdzony: SAMOCHOD \pfun PRZEGLAD
\where
	zatwierdzony \subseteq sprawnosc
\end{schema}

Potrzeba teraz dwóch operacji do zmiany stanu systemu: $Zarejestruj$ \\
i $Wyrejestruj$. Oto $Zarejestruj$, które ma dwa parametry: osoba $o?$ i
samochód $s?$.

\begin{schema}{Zarejestruj}
	\Delta Rejestr \\
	\Xi Przeglady \\
	o?: OSOBA \\
	s?: SAMOCHOD:
\where
	s? \notin \dom zarejestrowany \\
	(s?, o?) \in pozwolenie \\
	s? \in \dom zatwierdzony \\
	zarejestrowany' = zarejestrowany \cup \{(s?, o?)\}
\end{schema}
$Zarejestruj$ ma trzy warunki. Samochód nie mo¿e ju¿ byæ zarejestrowany (nie
mo¿e byæ w dziedzinie $zarejestrowany$), osoba musi byæ w³a¶cicielem i samochód
musi posiadaæ wa¿ny przegl±d. Je¶li te warunki s± spe³nione operacja dodaje
parê $(o?, s?)$ do relacji $zarejestrowany$.

Analogiczna operacja $Wyrejestruj$:

\begin{schema}{Wyrejestruj}
	\Delta Rejestr \\
	o?: OSOBA \\
	s?: SAMOCHOD
\where
	s? \in \dom zarejestrowany \\
	zarejestrowany' = zarejestrowany \setminus \{(s?, o?)\}
\end{schema}
Samochód mo¿na wyrejestrowaæ, je¶li jest zarejestrowany.

Trzeba teraz okre¶liæ definicje dla przypadków, dla których warunki nie s±
spe³nione do zarejestrowania. S± trzy warunki, wiêc musz± byæ trzy
przypadki.

Pierwszy, ¿e samochód nie jest zarejestrowany, skoro para $(o?, s?)$
znajduje siê ju¿ w relacji $zarejestrowany$, to znaczy, ¿e samochód jest ju¿
dopuszczony do ruchu:

\begin{zed}
Dopuszczony \defs [~ \Xi Rejestr; s?: SAMOCHOD | s? \in \dom zarejestrowany ~]
\end{zed}

Drugi, ¿e osoba nie jest upowa¿niona do rejestracji.

\begin{schema}{Nieupowazniony}
	\Xi Rejestr \\
	o?: OSOBA \\
 	s?: SAMOCHOD
\where
	(s?,o?) \notin pozwolenie
\end{schema}

I trzeci, ¿e samochód nie ma wa¿nego przegl±du technicznego.

\begin{zed}
Niesprawdzony \defs [~ \Xi Rejestr; \Xi Przeglady; s?: SAMOCHOD | s? \in \dom zatwierdzony ~]
\end{zed}

Ca³kowita operacja rejestracji obejmuje wszystkie mo¿liwo¶ci.

\begin{zed}
	T\_Zarejestruj \defs Zarejestruj \lor Dopuszczony \\
\t1		\lor Nieupowazniony \lor Niesprawdzony
\end{zed}


\subsection{Projekt komunikacji miêdzy radiomodemami SATEL}

Tym razem przedstawiê formaln± specyfikacjê rzeczywistego projektu
komunikacji pomiêdzy radiomodemami SATEL. Protokó³ opisany w tej sekcji zosta³
zaimplementowany i uruchomiony. Za³o¿eniem systemu by³o opracowanie
komunikacji w systemie sk³adaj±cym siê ze stacji nadrzêdnej oraz jednej lub
kilku stacji podrzêdnych. Ze wzglêdu na architekturê modemów podstaw±
komunikacji by³o rozg³aszanie - tzn. jeden wêze³ wysy³a³ komunikat, a
wszystkie pozosta³e go odbiera³y.

Zak³ada siê, ¿e architektura systemu jest znana i niepotrzebna jest ani
elekcja jednostki nadrzêdnej, ani dynamiczne konfigurowanie jednostek
podrzêdnych (w³±czanie do transmisji, itp).

Zaczniemy od wprowadzenia zbioru wêz³ów i komunikatów:

\begin{zed} [NODES, MESSAGES] \end{zed}

Maksymalna liczba wêz³ów:

\begin{axdef} max\_nodes: \nat \end{axdef}

Wêz³y s± adresowane liczb± naturaln±. Adresy nie mog± siê powtarzaæ. Mo¿na
zatem zapisaæ sieæ wêz³ów jako injekcjê zbioru wêz³ów na zbiór
liczb naturalnych:

\begin{axdef}
	network: NODES \inj \nat
\end{axdef}

Zdefiniujmy teraz zbiór pakietów. Ka¿dy pakiet sk³ada siê z adresu wêz³a
oraz z komunikatu.

\begin{axdef}
	PACKETS : \ran network \cross MESSAGES
\end{axdef}

Przyda siê nam funkcja $address$, która dla podanego wêz³a $w$ przyporz±dkuje
jego adres:

\begin{axdef}
	address: NODES \fun \nat
\where
	\forall w: NODES @ \\
\t1		(\exists l : network | first~l = w @ address(w) = second~l) \land \\
\t1		(w \notin \dom network \iff address(w) = 0)
\end{axdef}

Nastêpnym u¿ytecznym pojêciem bêdzie potwierdzenie komunikatu, które te¿
jest komunikatem. Specyfikujemy wiêc funkcjê $ACK$:

\begin{axdef}
	ACK: MESSAGES \fun MESSAGES
\end{axdef}

Zdefiniujmy zatem system, który sk³ada siê z jednej stacji nadrzêdnej $m$ i
jednej lub kilku podrzêdnych. System mo¿e byæ w stanie SEND lub RECEIVE (co
zostanie opisane pó¼niej). Z ka¿dym wêz³em powi±zana jest kolejka
komunikatów wej¶ciowych, co jest wyra¿one za pomoc± funkcji $queues$.

\begin{schema}{System}
	m : network \\
	slaves: \power network \\
	queues: NODES \fun \seq MESSAGES \\
	state: \{SEND, RECEIVE\}
\where
	\# slaves \in \{1 \upto max\_nodes-1\} \\
	\# queues = 1 + \# slaves \\
	\dom queues = \dom slaves \cup \{~ first~m ~\}
\end{schema}

W powy¿szym schemacie wprowadzona zosta³a równie¿ definicja stanu.

Mamy teraz wszystko, aby opisaæ operacjê wys³ania pakietu z wêz³a
nadrzêdnego do podrzêdnego - $TransmitMtoS$. Aby operacja zakoñczy³a siê
sukcesem, wymagane jest potwierdzenie otrzymania pakietu przez wêze³
podrzêdny. Mo¿emy wiêc wyodrêbniæ trzy przypadki.

\begin{schema}{TransmitMtoS\_Success}
	\Delta System \\
	p?: PACKETS \\
\where
	\forall s \in slaves | address(s) = first~p? @ \\
\t1		queues' = queues~ \oplus \\
	\{~ s \mapsto (queues(s) \cat \langle second~p? \rangle), 
				~ m \mapsto (queues(m) \cat \langle ACK(second~p?) \rangle) ~\}
\end{schema}

Sukces tej operacji wynika z faktu, ¿e zarówno do kolejki komunikatów
docelowego wêz³a podrzêdnego zosta³ dodany komunikat z pakietu, jak równie¿
¿e do kolejki komunikatów nadawcy zosta³o dodane potwierdzenie.

Mo¿e siê jednak zdarzyæ sytuacja, kiedy nie dojdzie potwierdzenie do nadawcy.

\begin{schema}{TransmitMtoS\_FailReceive}
	\Delta System \\
	p?: PACKETS \\
\where
	\forall s \in slaves | address(s) = first~p? @ \\
\t1		queues' = queues~ \oplus ~\{~ s \mapsto (queues(s) \cat \langle second~p? \rangle) ~\} 
\end{schema}

Pozostaje jeszcze sytuacja, kiedy w ogóle komunikat nie zostanie dostarczony odbiorcy:

\begin{schema}{TransmitMtoS\_FailSend}
	\Xi System \\
\end{schema}

Ca³kowita operacja $TransmitMtoS$ obejmuje wszystkie trzy mo¿liwo¶ci.

\begin{zed}
	TransmitMtoS \defs TransmitMtoS\_Success \lor \\
\t2		TransmitMtoS\_FailSend \lor TransmitMtoS\_FailReceive
\end{zed}

W systemie przewidziana jest równie¿ komunikacja pomiêdzy wêz³ami
podrzêdnymi. W analogiczny sposób mo¿na zdefiniowaæ operacjê $TransmitStoS$,
która zawiera operacje sk³adowe (ich definicje pomijam).

\begin{zed}
	TransmitStoS \defs TransmitStoS\_Success \lor \\
\t2		TransmitStoS\_FailSend \lor TransmitStoS\_FailReceive
\end{zed}

Transmisjê z wêz³a podrzêdnego do nadrzêdnego (operacja $TransmitStoM$)
opisuje siê w ten sam sposób. Nale¿y jednak zauwa¿yæ, ¿e dotychczas
zdefiniowali¶my jedynie funkcjonalno¶æ transmisji komunikatu, a dok³adniej
fakt, ¿e po udanym przes³aniu pakietu stacja otrzymuje potwierdzenie, a dany
pakiet jest dodawany do kolejki stacji docelowej. Przejdziemy teraz do
definicji w jaki sposób mo¿e to byæ zrealizowane.

Jak ju¿ zosta³o wspomniane, system mo¿e siê znajdowaæ w stanie SEND lub RECEIVE.

\subsubsection*{SEND}

Stan ten wykorzystywany jest podczas transmisji danych z wêz³a nadrzêdnego
do podrzêdnego. Je¶li system znajduje siê w tym stanie, to wys³anie pakietu
od nadrzêdnego do podrzêdnego wymaga jedynie wykonania operacji
$TransmitMtoS\_Success$. Mo¿emy wiêc zapisaæ:

\begin{zed}
SendMtoS\_Success \defs [~ \Delta System; p? : PACKETS | \\
\t2		(state = SEND) \land (TransmitMtoS\_Success(p?)) ~]
\end{zed}

\subsubsection*{RECEIVE}

W tym stanie w systemie mo¿e byæ przes³any komunikat od wêz³a podrzêdnego
(który normalnie nie mo¿e zainicjowaæ transmisji) do nadrzêdnego lub do
innych podrzêdnych. Jest to zrealizowane poprzez cykliczne odpytywanie 
wêz³ów podrzêdnych przez nadrzêdny.

Wêze³ nadrzêdny wysy³a pakiet startu z adresem jednostki podrzêdnej.
Nastêpnie podrzêdny ma obowi±zek wys³aæ potwierdzenie (jest to 
operacja $TransmitMtoS$), a potem pakiet przeznaczony dla innych jednostek.
Pakiety te s± adresowane, a poniewa¿ wszystkie jednostki (³±cznie z 
nadrzêdn±) nas³uchuj±, mog± wtedy odebraæ dane dla nich przeznaczone. 
Po wys³anym pakiecie adresowana jednostka musi `odpowiedzieæ' - czyli 
potwierdziæ pakiet. S± to operacje $TransmitStoM$ oraz $TransmitStoS$.
Nastêpnie z powrotem prawo nadawania przyznawane jest stacji nadrzêdnej.

Proces ten sk³ada siê zatem z trzech etapów:

\begin{enumerate} 
\item{} inicjalizacji transmisji, co odbywa siê poprzez wys³anie pakietu
startu od stacji nadrzêdnej do podrzêdnej i przej¶cie do stanu RECEIVE,
\item{} przes³ania komunikatu od stacji podrzêdnej,
\item{} zakoñczenia transmisji - powrotu do stanu SEND.
\end{enumerate}

Zak³adamy, ¿e transmisjê rozpoczynamy w stanie SEND. Mamy wiêc pocz±tek
transmisji:

\begin{zed}
SendStart \defs [~ TransmitMtoS | \\
\t1	p? = start\_packet \land state = SEND \land state' = RECEIVE ~] \hide (p?)
\end{zed}

i koniec:

\begin{zed}
SendEnd \defs [~ \Delta System | state' = SEND ~]
\end{zed}

Definiujemy zatem operacje $SendStoSSuccess$.

\begin{zed}
SendStoS\_Success \defs SendStart \semi TransmitStoS\_Success \semi SendEnd
\end{zed}

Oraz $SendStoMSuccess$.

\begin{zed}
SendStoM\_Success \defs SendStart \semi TransmitStoM\_Success \semi SendEnd
\end{zed}

Przyk³ad ten ilustruje wykorzystanie ró¿nych narzêdzi matematycznych
\zet. Specyfikacji tej mo¿na zarzuciæ te¿ brak niektórych detali, np.
nie ma tu opisu zale¿no¶ci czasowych. Wykorzystano niedeterminizm
\zet, który stwarza ró¿ne mo¿liwo¶ci implementacji podanego systemu.
Przyk³adowo operacja $TransmitMtoS\_FailReceive$ 'zakoñczy siê sukcesem', 
je¶li jej wynikiem bêdzie to, ¿e do zbioru kolejek w systemie zostanie
dodany pakiet wys³any, ale nie odebrany.

Mo¿na to zaimplementowaæ na kilka sposobów, np. ustaliæ limit czasowy 
(ang. {\it timeout}), albo sprawdziæ sumê kontroln± CRC odebranego
potwierdzenia (nawet gdy pakiet dojdzie, ale z b³êdem, to nie zostanie 
to uznane jako potwierdzenie) - w sytuacjach awaryjnych bêdziemy mieli do
czynienia z t± operacj±. 

Zale¿nie od wymaganego poziomu szczegó³owo¶ci specyfikacja taka mog³aby
byæ rozwijana; decyzja taka jest podejmowana przez projektanta, np. w 
oparciu o posiadane do¶wiadczenie zespo³u lub dostêpno¶æ gotowych i
przetestowanych komponentów realizuj±cych opisywane funkcje.

\chapter{Dowodzenie poprawno¶ci}\label{r:proving}

\section{Dowodzenie jako element metodologii projektowania}

B³êdy w programach komputerowych s± plag± od pocz±tku ich istnienia. Ich
¼ród³a bywaj± ró¿ne, w wiêkszo¶ci przypadków s± jednak powodowane przez
pomy³kê cz³owieka. Mog± powstawaæ na ró¿nych etapach powstawania
oprogramowania, zarówno w fazie projektu, jak i implementacji. Z tego
wszystkiego najbardziej niebezpieczne s± nieprawid³owo¶ci i nie¶cis³o¶ci
projektu. Koszt naniesienia poprawek do implementacji jest stosunkowo
niewielki, je¶li jednak oka¿e siê, ¿e b³êdy wkrad³y siê do projektu i
zostanie to wykryte w koñcowej fazie produkcji, to konsekwencje tego mog±
byæ bardzo kosztowne. Nie tylko koszty s± jednak istotne. Wiele
wspó³czesnych urz±dzeñ, których awaria mog³aby kosztowaæ ¿ycie ludzkie, jest
obecnie budowanych w oparciu o systemy mikroprocesorowe. W takich
przypadkach poprawne zaprojektowanie oprogramowania steruj±cego jest spraw±
nadrzêdn±.

Wtedy przychodz± z pomoc± metody formalne, poniewa¿ nie tylko umo¿liwiaj±
precyzyjne i jednoznaczne przekazanie zamierzeñ projektanta programi¶cie,
ale równie¿ analizê poprawno¶ci i weryfikacjê za³o¿eñ na etapie budowania
specyfikacji. Ich stosowanie umo¿liwia badanie wielu aspektów przysz³ego
systemu - przewidywanie stanu systemu po wykonaniu jakiej¶ operacji, lub
udowodnienie poprawnej obs³ugi sytuacji wyj±tkowych.

Rozdzia³ ten pokazuje typowe techniki i przyk³ady towarzysz±ce weryfikacji \zet.

\section{Zastosowanie rachunku predykatów do dowodzenia poprawno¶ci}

Formalne opisywanie procesów, systemów, algorytmów i struktur danych
umo¿liwia ich analizê za pomoc± dostêpnych metod matematycznych. Jedn± z
nich jest rachunek predykatów, który dostarcza metod po³±czenia celów
przy¶wiecaj±cych projektowi, za³o¿eñ co do funkcjonalno¶ci - z detalami
dotycz±cymi szczegó³ów projektowych.

Mo¿emy za³o¿yæ, ¿e specyfikacja jest poprawna w sensie formalnym, je¶li
poszczególne jej elementy nie wykluczaj± siê wzajemnie, s± spójne, oraz jest
spe³niony zbiór za³o¿eñ, czêsto znanych od pocz±tku tworzenia systemu -
czyli teorematów. Tworz±c np. system obs³uguj±cy transakcje bankowe
podstawowym teorematem jest, ¿e pieni±dze nie gin±, tzn. suma ¶rodków
zgromadzonych na rachunkach przed transakcj± jest sum± wynikaj±c± z bilansu
zaksiêgowanych operacji. Projektuj±c system okre¶lamy szczegó³owo, co to
jest rachunek, co znaczy wp³ata i wyp³ata, a nastêpnie za pomoc±
przekszta³ceñ matematycznych wynikaj±cych z logiki oraz innych znanych
twierdzeñ (równie¿ ju¿ udowodnionych teorematów specyfikacji) mo¿emy
udowodniæ prawdziwo¶æ danego twierdzenia, pokazuj±c w ten sposób, ¿e system
zaprojektowany zgodnie z t± specyfikacj± bêdzie dzia³a³ w/g dok³adnie
okre¶lonych za³o¿eñ.

S± dostêpne narzêdzia automatyzuj±ce ten proces, co zostanie
pokazane w dalszej czê¶ci pracy.

\section{Typowe b³êdy specyfikacji}

Matematyczny zapis za³o¿eñ projektowych ma niew±tpliwie wiele zalet, mo¿e
siê jednak okazaæ, ¿e projektant pope³ni³ b³êdy, które powoduj±, ¿e
specyfikacja jest wewnêtrznie sprzeczna lub niespójna, albo po prostu ¼le
zapisana. Sam fakt formalnego wyra¿enia problemu nie oznacza poprawno¶ci
projektu. Przedstawimy teraz klasy problemów, z jakimi mo¿e siê spotkaæ
twórca tekstu w \zet.

\subsection{B³êdy sk³adni i typów}

Jêzyk \zet ma bardzo bogat±, a przez to skomplikowan± sk³adniê. Ze wzglêdu
na mnogo¶æ elementów matematycznych i operatorów jeszcze bardziej z³o¿ony
jest aparat matematyczny \zet. Powoduje to, ¿e bardzo ³atwo jest pomyliæ siê
ju¿ w samym zapisie.

\zet jest wprawdzie notacj± beztypow±, nie znaczy to jednak, ¿e nie mo¿na
tych typów w niej wyraziæ, lub ¿e ich siê nie stosuje. System typów w \zet
jest zbudowany na bazie teorii zbiorów oraz ograniczeñ stosowania elementów
aparatu matematycznego. Przyk³adowo je¶li próbujemy u¿yæ operatora relacji 
do czego¶, co nie jest relacj±, albo znaków dzia³añ arytmetycznych
w odniesieniu do danych, które nie s± liczbami. Pomy³ki tego typu s±
do¶æ oczywiste i ³atwe do zidentyfikowania.

Sprawa jest bardziej skomplikowana, gdy spróbujemy zaaplikowaæ argument,
którego typ jest niekompatybilny z danym zapisem, tzn. nale¿y on do zbioru,
który jest roz³±czny ze zbiorem dopuszczalnych warto¶ci. Przyk³adowo:

\begin{schema}{Sklep}
	towary : TOWAR \fun CENA
\end{schema}

\begin{schema}{NowyTowar}
	\Delta Sklep \\
	t? : TOWAR
\where
	towary' = t? \dres towary
\end{schema}

Argument $t?$ powinien byæ par± $(TOWAR, CENA)$, czyli uogólniaj±c nale¿eæ
do zbioru $TOWAR \cross CENA$, a nie do $TOWAR$. Zbiory te s± roz³±czne,
wiêc taka definicja operacji $NowyTowar$ jest nieprawid³owa.

B³êdy zwi±zane ze sk³adni± i systemem typów s± naj³atwiejsze do wykrycia.

\subsection{B³êdy dziedziny}

W \zet mo¿liwe jest zapisanie wyra¿enia, które ma nieokre¶lone znaczenie.
Mo¿e to zdarzyæ siê w dwóch przypadkach:

\begin{enumerate}
\item{} podczas przekazania funkcji argumentu, który nie znajduje siê w jej
dziedzinie (np. $\# \nat$, $max~\num$),
\item{} w przypadku u¿ycia $\xmu-$wyra¿enia, dla którego nie istnieje
warto¶æ spe³niaj±ca jego predykat (np. $\mu x : \num | x \neq x$), lub
istnieje wiele takich warto¶ci (np. $\mu x : \nat | 0 * x = 0$).
\end{enumerate}

Predykat zawieraj±cy takie nieokre¶lone wyra¿enie mo¿e byæ ró¿nie
interpretowany. Praca Spivey'a \cite{Spivey-ZRM} nie precyzuje jak powinna
byæ traktowana nieokre¶lono¶æ, jednak standard \zet mówi, ¿e taki predykat ma
warto¶æ $false$. 

B³êdy dziedziny nie zawsze mog± byæ wykryte za pomoc± prostej kontroli
typów. Do dowiedzenia ich poprawno¶ci mo¿na u¿yæ nastêpuj±cego mechanizmu,
który jest zaimplementowany w systemie {\bf Z/EVES}. Maj±c dany schemat
\begin{zed} S \defs [~ D | P ~] \end{zed} poprawno¶æ w sensie 
dziedzin jest zagwarantowana, je¶li spe³nione jest

\begin{zed}
	S \land quantifiers(S) \implies domain\_check(S)
\end{zed}

$domain\_check(S)$ jest predykatem, który tworzymy z $P$ za pomoc± algorytmu:

\begin{enumerate}

\item{} wybieramy z $P$ wszystkie odwo³ania do funkcji, np. predykat
\begin{zed} \forall x : X @ fun(x) < fun(gfun(x)) \end{zed} tworzy listê: 
$fun(x)$, $gfun(x)$, $fun(gfun(x))$,

\item{} dla ka¿dego odwo³ania postaci $f(x)$ otrzymujemy warunek 
$x \in \dom f$. W podanym przyk³adzie mamy listê warunków: 
\begin{zed}x \in \dom fun$, $x \in \dom gfun$, $gfun(x) \in \dom fun\end{zed}

\item{} z otrzymanej listy warunków $p_1, \dots, p_n$ powstaje
predykat\footnote{Nale¿y zauwa¿yæ, ¿e w podanym przypadku wystêpuje u¿ycie operatora $<$, 
który równie¿ posiada ograniczenia jego stosowania (a konkretnie argumenty
po obu stronach musz± nale¿eæ do zbiorów, pomiêdzy którymi okre¶lona jest
relacja porz±dku) - mo¿na to jednak z³o¿yæ na karb kontroli typów \zet.}
\begin{zed}domain\_check(S) \iff p_1 \land \dots \land p_n \end{zed}
\end{enumerate}

Nastêpnie bierzemy z $P$ wszystkie zmienne kwantyfikowane, których
typ równie¿ tworzy warunek, tu $x \in X$. Koniunkcja tych warunków jest
predykatem $quantifiers(S)$.

We¼my przyk³ad z \cite{Z-EVES-RM}:

\begin{schema}{Personnel}
employees : \power PERSON \\
boss\_of : PERSON \pfun PERSON \\
salary : PERSON \pfun \nat
\where
\dom salary = employees \\
\forall e : employees @ salary(e) < salary(boss\_of~e)
\end{schema}

Predykat $domain\_check(Personnel)$ ma postaæ:

\begin{zed}
e \in \dom salary \land e \in \dom boss\_of \land boss\_of~e \in \dom salary
\end{zed}

Po analizie tego wyra¿enia oka¿e siê, ¿e ta definicja jest b³êdna, gdy¿ nic
nie jest powiedziane na temat dziedziny, ani zbioru warto¶ci funkcji czê¶ciowej
$boss\_of$, zatem nie da siê np. dowie¶æ, ¿e $boss\_of~e \in \dom salary$.

Poprawnym schematem jest wiêc

\begin{schema}{Personnel}
employees : \power PERSON \\
boss\_of : PERSON \pfun PERSON \\
salary : PERSON \pfun \nat
\where
\dom salary = employees \\
\dom boss\_of \subseteq employees \\
\ran boss\_of \subseteq employees \\
\forall e : employees @ salary(e) < salary(boss\_of~e)
\end{schema}

\subsection{Niespójno¶æ}

Specyfikacja jest rozumiana jako opis mo¿liwego systemu. Je¶li nie istnieje taki
model systemu, który spe³nia³by jej wymagania, to znaczy ¿e specyfikacja jest 
{\it niespójna}.

\subsubsection{Lokalna niespójno¶æ}

Niespójno¶æ lokalna wystêpuje w przypadku, gdy dany schemat $S$ posiada predykat 
niemo¿liwy do spe³nienia. Przyk³adowo:

\begin{schema}{S}
	n : \num
\where
	n \neq n
\end{schema}

Je¿eli taki schemat jest u¿yty do opisania stanu systemu, to stan ten jest 
nieosi±galny, a system niemo¿liwy do zrealizowania. Je¶li by³aby to operacja, to
nie mog³aby byæ ona wykonana pomy¶lnie.

Ogólnym warunkiem spójno¶ci schematu jest predykat:

\begin{zed}
	\exists S @ true	
\end{zed}

W punkcie \ref{r:init_state} opisano pojêcie stanu pocz±tkowego. W takim wypadku
powy¿szy predykat mo¿e byæ rozszerzony do postaci:

\begin{zed}
	\exists S @ Init\_S
\end{zed}

Dowód takiego teorematu mówi, ¿e istniej± mo¿liwe warto¶ci sygnatury $S$, oraz ¿e
osi±galny jest równie¿ ich stan pocz±tkowy.

\subsubsection{Globalna niespójno¶æ}

Opisana niespójno¶æ z poprzedniego punktu ma charakter lokalny, gdy¿ dotyczy
sk³adowych elementów specyfikacji. Mo¿liwa jest jednak sytuacja, ¿e poszczególne
paragrafy specyfikacji s± prawid³owe, jednak ich po³±czenie wyklucza istnienie modelu
systemu. Wtedy mamy do czynienia z niespójno¶ci± globaln±, która sprawia, ¿e 
specyfikacja jako ca³o¶æ jest nieprawid³owa.

B³êdy mog± kryæ siê w aksjomatach, definicjach uogólnionych (patrz 
p. \ref{r:generic_definitions}), lub predykatach.

Spójno¶æ definicji aksjomatycznej postaci

\begin{axdef}
	D
\where
	P
\end{axdef}

mo¿e byæ udowodniona za pomoc± predykatu:

\begin{zed}
	\exists D @ P
\end{zed}

Trudniejsze przypadki pojawiaj± siê, gdy grupa paragrafów jest niespójna, np.

\begin{axdef}x,y : \nat \end{axdef}

\begin{zed}
x \in {1..3} \\
\dots \\
y < 1 - 3 * x
\end{zed}

W rzeczywistych specyfikacjach paragrafy te mog± byæ rozdzielone
kilkunastoma innymi definicjami, a s± one niespójne dopiero w po³±czeniu,
mo¿e zatem to byæ trudne do wykrycia. Dobr± praktyk± jest grupowanie
odwo³uj±cych siê do siebie deklaracji, a je¶li jest to niemo¿liwe -
wprowadzanie dodatkowych konstrukcji wi±¿±cych w³a¶ciwo¶ci grupy paragrafów.

\subsection{B³êdy z punktu widzenia logiki specyfikacji}

Ze wzglêdu na bogactwo sk³adni \zet i skomplikowanie aparatu matematycznego,
nie jest trudno skonstruowaæ poprawn± w sensie formalnym specyfikacjê, ale
niezgodn± z zamierzeniami projektanta. W takim wypadku, pomimo ¿e
wprowadzone schematy, twierdzenia i teorematy s± spójne i prawid³owe pod
wzglêdem matematycznym, to nie opisuj± one oczekiwanego systemu. 

Takie b³êdy s± najtrudniejsze do wykrycia i s± niezauwa¿alne dla
automatycznych narzêdzi sprawdzaj±cych i wspomagaj±cych specyfikacjê w \zet.
Dlatego wskazane jest przemy¶lenie strategii testowania projektu w postaci
przygotowania jak najwiêkszej ilo¶ci teorematów testowych opisuj±cych
poprawny system (patrz p. \ref{r:test_theorems}).

\section{Techniki dowodzenia poprawno¶ci}

\subsection{Indukcja}

Indukcja jest klasyczn± metod± dowodzenia, która mo¿e byæ zastosowana w
stosunku do ci±gów, zbiorów, sekwencji oraz typów wolnych.

\subsubsection{Ci±gi}

Aby dowie¶æ, ¿e w³a¶ciwo¶æ $P(n)$ odnosi siê do wszystkich elementów ci±gu
$n$, wystarczy pokazaæ, ¿e:

\begin{enumerate}
\item{} $P(0)$ jest spe³nione,
\item{} je¶li spe³nione jest $P(n)$ dla pewnego $n : \nat$, to wynika z
tego równie¿ $P(n+1)$:
\begin{zed}
\forall n : \nat @ P(n) \implies P(n+1)
\end{zed}
\end{enumerate}

Je¶li trudno jest udowodniæ prawdziwo¶æ $P(n)$ tylko z w³a¶ciwo¶ci
poprzednika, mo¿na pos³u¿yæ siê potê¿niejsz± wersj± indukcji: z faktu, ¿e
wszystkie elementy poprzedzaj±ce $n$ spe³niaj± $P(k)$ (dla $k < n$) wynika
prawdziwo¶æ $P(n)$. Odpowiada to zapisowi:

\begin{zed}
\forall n : \nat @ (\forall k : \nat | k < n @ P(k)) \implies P(n)
\end{zed}

\subsubsection{Zbiory}

Indukcja pomocna jest w dowodzeniu w³a¶ciwo¶ci zbiorów skoñczonych.
Korzystaj±c z faktu, ¿e ka¿dy zbiór skoñczony mo¿e zostaæ `skonstruowany' ze
zbioru pustego poprzez stopniowe dodawanie nowych elementów, ³atwo formu³uje
siê zasady indukcji. $P(S)$ jest zachowane dla wszystkich zbiorów skoñczonych 
$S : \finset X$, gdy:

\begin{enumerate}
\item{} $P(\emptyset)$ jest spe³nione,
\item{} je¶li spe³nione jest $P(S)$ dla pewnego zbioru $S$, to wynika z
tego równie¿ \nowalinia $P(~S \cup \{x\}~)$:
\begin{zed}
\forall S : \finset X; x : X @ P(S) \implies P(~S \cup \{x\}~)
\end{zed}
\end{enumerate}

Analogicznie do pierwszego punktu dostêpna jest potê¿niejsza wersja, któr±
mo¿na wyraziæ: pewna w³a¶ciwo¶æ charakteryzuje zbiór $S$, je¶li wynika ona ze
spe³nienia jej dla wszystkich podzbiorów $S$. Zatem 
$\forall S : \finset X @ P(S)$ je¶li:

\begin{zed}
\forall S : \finset X @ (\forall T : \finset X | T \subset S @ P(T)) \implies P(S)
\end{zed}

\subsubsection{Sekwencje}

Sekwencje maj± zdefiniowane pojêcie konkatenacji, \zet dopuszcza te¿
sekwencje puste. Analogicznie zatem do zbioru skoñczonego, sekwencja mo¿e
zostaæ `skonstruowana' z sekwencji pustej poprzez kolejne dodawanie
elementów. Elementy te mog± byæ jednak wstawiane na kilka sposobów.

Pierwszy warunek indukcji jest standardowy:

\paragraph{}
(abc1) \t1 $P(\langle\rangle)$ jest spe³nione.

\paragraph{}
Kolejne warunki zale¿± od sposobu budowania sekwencji w regule indukcyjnej.
Je¶li elementy dodawane s± na pocz±tek, to regu³a ma postaæ:

\paragraph{}
(a2) \t1	je¶li spe³nione jest $P(s)$ dla pewnej sekwencji $s$, to wynika z
tego $P(\langle x\rangle \cat s)$: 

\begin{zed}
\forall s : \seq X; x : X @ P(s) \implies P(\langle x\rangle \cat s)
\end{zed}

Elementy dodawane na koniec:
\paragraph{}
(b2) \t1	je¶li spe³nione jest $P(s)$ dla pewnej sekwencji $s$, to wynika z
tego $P(s \cat \langle x\rangle)$: 

\begin{zed}
\forall s : \seq X; x : X @ P(s) \implies P(s \cat \langle x\rangle)
\end{zed}

Istnieje jeszcze jedna strategia tworzenia sekwencji. Zamiast zaczynaæ od
sekwencji pustej, mo¿na dowie¶æ równie¿ w³a¶ciwo¶ci poszczególnych elementów 
$\langle x \rangle$ i sekwencje d³u¿sze otrzymywaæ poprzez konkatenacjê krótszych.
Daje to dwa warunki:

\paragraph{}
(c2) \t1	Dla ka¿dego $x : X$ spe³nione jest $P(\langle x \rangle)$,

\paragraph{}
(c3) \t1	je¶li spe³nione s± warunki $P(s), P(t)$ dla pewnych sekwencji $s, t$, 
to wynika z tego $P(s \cat t)$: 

\begin{zed}
\forall s,t : \seq X @ P(s) \land P(t) \implies P(s \cat t)
\end{zed}

Ostatni sposób mo¿e wydawaæ siê bardziej skomplikowany ze wzglêdu na
konieczno¶æ dowodu trzech warunków zamiast dwóch, ale czêsto okazuje siê ¿e
jest on ³atwiejszy do przeprowadzenia.

\subsubsection{Typy wolne}

Indukcja ma zastosowanie w sprawdzaniu spójno¶ci dla typów wolnych.
Regu³y indukcyjne podane s± w \ref{r:free_types}.

\subsection{Test warunków wstêpnych}

Warunki wstêpne, jak wspomniano ju¿ w punkcie \ref{r:operations}, s±
predykatami okre¶laj±cymi mo¿liwe warto¶ci argumentów operacji, które
gwarantuj± jej pomy¶lne wykonanie. Aby dowie¶æ, ¿e $P$ jest poprawnym
warunkiem wstêpnym, nale¿y pokazaæ, ¿e:

\begin{zed}
	\forall S; in? : IN | P @ \pre Op
\end{zed}

Lista takich teorematów skutecznie opisuje ograniczenia danego systemu.
Je¿eli operacja mo¿e wykonaæ siê dla dla dowolnych argumentów, w dowolnym
stanie, to teoremat

\begin{zed}
	\forall S; in? : IN @ \pre Op
\end{zed}

jest prawdziwy. 

Stosowanie testu warunków wstêpnych konieczne jest podczas dowodzenia
poprawno¶ci z³o¿enia operacji (patrz definicje w \ref{r:semi_operator}).

\subsection{Niezmienniki}

Niezmiennik jest predykatem, który jest spe³niony niezale¿nie od
wykonywanych operacji na systemie. Je¶li umie¶cimy taki predykat w schemacie
postaci

\begin{schema}{Inv}
	System
\where
	P
\end{schema}

to jest spe³nione:

\begin{zed}
	(Init \implies Inv) \land (Op \land Inv \implies Inv')
\end{zed}

przy za³o¿eniu, ¿e $Op$ jest operacj±, a $Init$ opisuje stan pocz±tkowy.

Przyk³adem systemu z niezmiennikiem mo¿e byæ implementacja bufora,
zawieraj±cego wska¼nik $r$.

\begin{schema}{Buffer}
	r : \num
\end{schema}

Stan pocz±tkowy (bufor pusty):

\begin{schema}{Init}
	Buffer
\where
	r = 0     
\end{schema}

I operacja dodawania elementów do bufora:

\begin{schema}{Add}
	\Delta Buffer
\where
	r' = r + 1
\end{schema}

Niezmiennikiem jest fakt, ¿e wska¼nik bufora jest liczb± naturaln±:

\begin{schema}{Invariant}
	Buffer
\where
	r \in \nat
\end{schema}

Zatem $(Init \implies Invariant) \land (Add \land Invariant \implies Invariant') \iff true$.

Niezmienniki s± u¿yteczne, gdy

\begin{itemize}

\item{} chcemy zagwarantowaæ zachowanie pewnych wa¿nych ograniczeñ,
kluczowych dla bezpieczeñstwa systemu (np. ¿e temperatura spalania nie
przekroczy progu),

\item{} niezmienno¶æ jakiego¶ faktu jest przydatna dla programisty w
zastosowaniu bardziej efektywnego algorytmu.
 
\end{itemize}

Nale¿y zauwa¿yæ, ¿e predykaty wewn±trz schematu równie¿ mog± byæ
niezmiennikami, ale bywaj± sytuacje, kiedy potrzebne jest zadeklarowanie
nowego, dedykowanego niezmiennikowi schematu. Jest tak gdy maj±c dwie
operacje, chcemy okre¶liæ sta³± w³a¶ciwo¶æ, niezale¿nie od ich wykonania.
Poniewa¿ przed zadeklarowaniem niezmiennika obie operacje musz± byæ
wprowadzone do specyfikacji, konieczny jest trzeci schemat.

Je¿eli system jest zdefiniowany przez operacje $Op_1 \dots Op_n$ i 
$\pre Op_1 \land \dots \land \pre Op_n$ jest niezmiennikiem, to w systemie
nie wystêpuj± sytuacje wyj±tkowe (wykonanie operacji $Op_1 \dots Op_n$
zawsze jest mo¿liwe).

\subsection{Testowe teorematy}\label{r:test_theorems}

Poprawno¶æ specyfikacji mo¿e te¿ byæ rozumiana jako zachowanie prawdziwo¶ci
teorematów, przyjêtych jako za³o¿enia przed jej powstaniem. Takie teorematy
mog± byæ u¿ytecznym sposobem wyra¿enia kluczowych warunków poprawno¶ci
danego systemu. Przyk³adowo w programie steruj±cym sygnalizacj± ¶wietln±
takim warunkiem mo¿e byæ wykluczenie sytuacji, w której zielone ¶wiat³o jest
zapalone dla dwóch lub wiêcej przecinaj±cych siê pasów ruchu. We¼my schemat:

\begin{schema}{Skrzyzowanie}
	zapalone :  \nat \pfun \{~ 0, 1 \}~
\where
	\# (\dom zapalone) = n
\end{schema}

$n$ jest liczb± wykluczaj±cych siê linii sygnalizacyjnych, które nie powinny
byæ jednocze¶nie zapalone. We¼my zatem operacjê $Zmiana$

\begin{schema}{Zmiana}
	\Delta Skrzyzowanie
\where
	\forall x_1, x_2 : \dom zapalone | zapalone(x_1) = 1 \land zapalone'(x_2) = 1 @ x_1 \neq x_2 \\
	\dots
\end{schema}

Teorematem testowym jest warunek 

\begin{zed}
Zmiana \implies (~ \# \{~ \forall x : \dom zapalone | zapalone'(x) = 1 @ x \}~ = 1 ~)
\end{zed}

czyli, ¿e po wykonaniu operacji $Zmiana$ bêdzie zapalona tylko jedna linia
sygnalizacyjna (i bêdzie to inna linia ni¿ przed operacj±).

Dowodz±c prawdziwo¶ci testowych teorematów mo¿emy sprawdziæ nie tylko
spe³nienie za³o¿eñ wstêpnych, ale równie¿ badaæ zachowanie wyspecyfikowanego
systemu w sytuacjach wyj±tkowych lub krytycznych.

\section{Zagadnienie uszczegó³owienia ({\it refinement})}

\subsection{Uszczegó³owienie w ujêciu ogólnym}

Tworz±c program z podanej specyfikacji, programista musi rozwi±zywaæ dwa rodzaje problemów:

\begin{itemize}

\item{}Zapisaæ struktury danych w odpowiedni sposób zdefiniowany przez jêzyk programowania,
aby odpowiada³y one zbiorom, relacjom i innym definicjom podanym w formalnej specyfikacji \zet.

\item{}Zdefiniowaæ algorytmy za pomoc± sk³adni i bibliotek ¶rodowiska, aby realizowa³y one
operacje na danych w sposób okre¶lony w specyfikacji za pomoc± jêzyka schematów.
\end{itemize}

Bazuj±c na ró¿nym stopniu z³o¿ono¶ci problemów, twórcy notacji \zet wprowadzili pojêcie 
uszczegó³owienia. Polega ono na tym, ¿e projektant mo¿e pracowaæ na ró¿nych poziomach
abstrakcji, na pocz±tku projektowania zale¿y mu g³ównie na stworzeniu ogólnych ram systemu,
opisuj±cych w sposób zwiêz³y dane i operacje na nich. W miarê dalszego rozwijania specyfikacji,
mo¿e on okre¶laæ bardziej szczegó³owe wersje schematów i operacji, które ju¿ zdefiniowa³,
przechodz±c w ten sposób na ni¿szy poziom abstrakcji. Pomaga to zarówno projektantom jak 
i programistom, mog± oni bowiem korzystaæ z ró¿nych czê¶ci specyfikacji o innym stopniu
trudno¶ci, w miarê potrzeby korzystaj±c odpowiednio z wersji ogólnej i szczegó³owej. Na 
podstawie podanych klas problemów wyró¿niamy wiêc uszczegó³owienie danych (ang. {\it data 
refinement}) oraz operacji (ang. {\it operation refinement}).

Z punktu widzenia dowodzenia poprawno¶ci formalnej i weryfikacji specyfikacji powstaje w ten
sposób problem formalnego dowiedzenia, ¿e dwie wersje tej samej operacji, ró¿ni±ce siê poziomem
szczegó³owo¶ci, opisuj± dok³adnie ten sam proces i ¿e spójne wobec siebie.  

Matematycznie ten problem mo¿na wyraziæ w sposób nastêpuj±cy. Maj±c 'abstrakcyjny' system
bêd±cy w stanie $A$, posiadaj±cy schemat pocz±tkowy $AI$ oraz operacjê $AO$, jak równie¿
odpowiadaj±cy 'konkretny' system w stanie $C$, ze schematem pocz±tkowym $CI$ i operacj± $CO$,
mo¿na skonstruowaæ pojêcie relacji $R$ ³±cz±cej oba te systemy. Zachodzi wtedy:

\begin{zed}
\forall CI @ \exists AI @ R
\end{zed}

Je¶li te dwa systemy rzeczywi¶cie sobie odpowiadaj±, to musz± byæ spe³nione dwa warunki. 
Pierwszy mówi, ¿e 'konkretna' operacja $CO$ mo¿e byæ wywo³ana wtedy, kiedy i 'abstrakcyjna':

\begin{zed}
\forall R | \pre AO @ \pre CO
\end{zed}

Drugi okre¶la, ¿e je¶li operacja 'abstrakcyjna' mo¿e byæ wywo³ana, to rezultat spójny z wynikiem
analogicznej operacji 'konkretnej':

\begin{zed}
\forall R; CO | \pre AO @ \exists A' @ AO \land R'
\end{zed}

\subsection{Uszczegó³owienie operacji}

Dwa przedstawione warunki dla dowodzenia w³a¶ciwo¶ci uszczegó³owienia operacji, mog± byæ
te¿ zapisane w poni¿szy sposób. Niech $x?$ bêdzie parametrem operacji. 

\begin{zed}
\forall State; x? : X @ \pre AO \implies \pre CO
\end{zed}

Wersja bez operatora $\pre$:

\begin{zed}
\forall State; x? : X @ \\
\t1	(\exists State'; y! : Y @ AO) \implies (\exists State'; y! : Y @ CO)
\end{zed}

Drugi warunek: je¶li warunek wstêpny operacji $AO$ jest spe³niony, to ka¿dy rezultat
jaki mo¿e zwróciæ operacja $CO$ musi byæ mo¿liwym rezultatem operacji $AO$:

\begin{zed}
\forall State; State'; x? : X; y! : Y @ \\
\t1	\pre AO \land CO \implies AO
\end{zed}

Wersja bez operatora $\pre$:

\begin{zed}
\forall State; x? : X @ \\
\t1	(\exists State'; y! : Y @ AO) \\
\t1	\implies (\forall State'; y! : Y @ CO \implies AO)
\end{zed}

\subsection{Uszczegó³owienie danych} 

Zagadnienie uszczegó³owienia danych rozszerza pojêcie uszczegó³owienia operacji w ten
sposób, ¿e pozwala, aby przestrzeñ stanów abstrakcyjnych operacji ró¿ni³a siê od przestrzeni
stanów operacji konkretnych. Problem ten odpowiada sytuacji, gdy programista maj±c do
dyspozycji definicje danych zawarte w specyfikacji za pomoc± abstrakcyjnych pojêæ, takich
jak zbiory lub relacje, musi zapisaæ je w sposób okre¶lony przez jêzyk programowania. Pierwszy
opis odpowiada wiêc specyfikacji, drugi - ju¿ konkretnemu projektowi. Oczywi¶cie w sensie 
notacji opis projektu równie¿ jest zapisany za pomoc± abstrakcyjnych pojêæ notacji, ró¿ni siê
jednak poziomem szczegó³owo¶ci.

Przechodz±c do problemu dowodzenia poprawno¶ci, dla uszczegó³owienia danych musimy równie¿
zapisaæ dwa warunki, analogiczne do tych opisanych w poprzednich podrozdzia³ach.

Pierwszy mówi, ¿e operacja na 'konkretnym' typie danych koñczy siê wtedy, kiedy równie¿ 
operacja 'abstrakcyjna' spe³nia warunki do zakoñczenia. Je¶li stany abstrakcyjny i konkretny
s± zwi±zane za pomoc± abstrakcyjnego schematu $Abs$ i stan abstrakcyjny spe³nia warunki
wstêpne operacji abstrakcyjnej $AO$, to równie¿ stan konkretny równie¿ musi spe³niaæ
warunki wstêpne operacji konkretnej.

\begin{zed}
\forall Astate; Cstate; x? : X @ \\
\t1 	\pre AO \land Abs \implies \pre CO
\end{zed}

Drugi warunek mówi o tym, ¿e stan po wykonaniu operacji 'konkretnej' odpowiada jednemu ze
stanów abstrakcyjnych, w jakich mog³a siê zakoñczyæ operacja abstrakcyjna $AO$. 

\begin{zed}
\forall Astate; Cstate; Cstate'; x? : X; y! : Y @ \\
\t1	\pre AO \land Abs \land CO \implies (\exists Astate' @ Abs' \land AO) 
\end{zed}

Oprócz tego, mo¿emy zapisaæ jeszcze jeden warunek dla stanów pocz±tkowych.

\begin{zed}
\forall Cstate @ \\
\t1	CI \implies (\exists Astate @ AI \land Abs)
\end{zed}

\chapter{System Z/EVES}

{\bf Z/EVES} jest systemem s³u¿±cym do tworzenia, sprawdzania oraz analizy
specyfikacji \zet. Mo¿e byæ u¿ywany do testów poprawno¶ci typów i dziedzin, eksplorowania
schematów, sprawdzania warunków wstêpnych (patrz p. \ref{r:operations}) oraz dowodzenia 
teorematów i faktów zwi±zanych z uszczegó³owieniem {\it (ang. refinement)}.
Obecnie jest to najbardziej zaawansowany system automatycznego
przeprowadzania dowodów dla notacji \zet.

Jest wyposa¿ony w maszynê dowodzenia {\it (ang. prover)} automatyzuj±cy
proces przeprowadzania dowodów, co czasem jest dokonywane w pe³ni 
automatycznie, bez udzia³u u¿ytkownika. Niemniej jednak aby efektywnie
go wykorzystywaæ niezbêdna jest wiedza na temat wewnêtrznej reprezentacji 
elementów specyfikacji oraz stosowanych przez niego technik.

{\bf Z/EVES} zgodny jest ze standardem ISO oraz bibliotek± \zet zawart± w tym
standardzie. Jest firmowany przez organizacjê ORA Canada
({\it http://www.ora.on.ca}) i zosta³ czê¶ciowo sfinansowany ze ¶rodków 
Departamentu Obrony USA.

\section{Koncepcja i mo¿liwo¶ci systemu}

{\bf Z/EVES} sk³ada siê z j±dra systemu, które jest intepreterem jêzyka
{\it EVES} i posiada wiedzê o logice i aparacie matematycznym. J±dro
to posiada wbudowany zestaw teorematów {\it (ang. mathematical toolkit)}, 
który umo¿liwia automatyczne sprawdzanie specyfikacji. Oprócz
tego dostêpny jest interfejs u¿ytkownika {\it (ang. GUI)}, który w
trybie graficznym prezentuje dan± specyfikacjê \zet, daj±c przy tym dostêp do
standardowych komend systemu Z/EVES. Specyfikacja mo¿e byæ
sprawdzona pod wzglêdem poprawno¶ci sk³adniowej i typów, jak równie¿
poprawno¶ci merytorycznej, popartej teorematami i znanymi twierdzeniami 
z zakresu logiki predykatów, arytmetyki i teorii mnogo¶ci.

Jêzykiem specyfikacji jest tekst zawieraj±cy instrukcje, których sk³adnia
jest zgodna z makrami {\LaTeX}. Z/EVES potrafi importowaæ matematyczne
zapisy notacji z dokumentów {\LaTeX}. Mog± one zatem byæ ¼ród³em
teorematów dla systemu {\bf Z/EVES}, jak równie¿ wchodziæ w sk³ad regularnej
dokumentacji systemu.

{\bf Z/EVES} zawiera zaawansowane mechanizmy do przeprowadzania
automatycznych dowodów. Wiêkszo¶æ oczywistych lub ³atwych faktów jest
dowodzona automatycznie. Jednak¿e zazwyczaj {\bf Z/EVES} nie radzi sobie z
trudniejszymi dowodami, wtedy u¿ytkownik musi znaæ dowód, albo chocia¿ jego
zarys.

Specyfikacja jest sprawdzana paragrafami. Sprawdzanie jest zintegrowane z
maszyn± dowodzenia, oprócz samej kontroli poprawno¶ci sk³adni podejmowana
jest próba dowodu. Do ka¿dego paragrafu mo¿na do³±czyæ zbiór komend
pozwalaj±cych na jego dowód (gdy¿ nie wszystkie daj± siê przeprowadziæ
automatycznie).  Poszczególne paragrafy s± dowodzone po kolei, z wiedz±
dostêpn± na etapie danego paragrafu. Oznacza to, ¿e je¶li do dowodu jakiego¶
paragrafu potrzebny jest lemat, to powinien on w specyfikacji poprzedzaæ
dany teoremat.

\section{Maszyna dowodzenia}

Jednym z celów towarzysz±cym twórcom systemu by³o jak najlepsze
zautomatyzowanie przeprowadzania dowodów. Okaza³o siê to jednak niemo¿liwe
lub znacznie utrudnione w wielu przypadkach, dlatego proces ten wymaga
czêsto ingerencji u¿ytkownika. Nastêpuje to poprzez wydawanie komend,
np. okre¶laj±cych rodzaj strategii dowodu, lub do³±czaj±cych do bie¿±cej
wiedzy konkretne twierdzenie z {\it Mathematical Toolkit}.

Wewnêtrznie notacja zamieniana jest na wyra¿enia beztypowego rachunku
predykatów. Oznacza to, ¿e nie ma `logiki \zet' jako takiej, operacje
na wyra¿eniach przeprowadza siê w przestrzeni rachunku predykatów, a
nastêpnie zostaj± one z powrotem zamienione na jêzyk zgodny z notacj± \zet.
Mo¿e siê zdarzyæ (co jest bardzo rzadkie), ¿e po przeprowadzeniu przekszta³ceñ
nie mo¿na sprowadziæ wyra¿eñ do formy \zet (nale¿y wtedy u¿yæ
jednej z regu³ przekszta³ceñ).

W notacji jest tylko typ - $\num$, natomiast rachunek predykatów
jest beztypowy. Informacja o typach jest zatem wyra¿ona i przetwarzana
logicznie, za pomoc± pojêæ zbiorów i zawierania, np. fakt, ¿e liczba $i$ 
jest typu ca³kowitoliczbowego, jest wyra¿ony przez $i \in \num$. Nie ma
w tym zaimplementowanych dodatkowych mechanizmów, które w specjalny sposób
traktowa³yby t± informacjê - u¿ywany jest ten sam zestaw regu³ dla
predykatów co zwykle.

Z ka¿dym dowodem zwi±zany jest tzw. kontekst, który reprezentuje aktualn±
wiedzê. Ka¿da specyfikacja rozpoczyna od kontekstu {\bf Mathematical
Toolkit}. Kolejne paragrafy powiêkszaj± tê wiedzê dodaj±c nowe teorematy.
Ka¿dy teoremat posiada nazwê, która mo¿e byæ pó¼niej u¿yta w dowodzie.
Je¿eli u¿ytkownik nie poda³ nazwy, zostaje ona przydzielona przez system
automatycznie. 

Przeprowadzenie dowodu wi±¿e siê z tzw. docelowym predykatem. Wyra¿enie
przekszta³cane jest w równowa¿ne, za pomoc± znanych regu³ logicznych i
komend maszyny dowodzenia. Dowód jest zakoñczony, je¶li uda siê doprowadziæ
do wyra¿enia {\it true}. Dla ³atwiejszych faktów komendy automatycznego
dowodzenia, jak np. {\bf prove by reduce}, czêsto koñcz± dowód w jednym
kroku, jednak je¶li tak siê nie dzieje, u¿ytkownik musi wspomóc automat
poprzez podanie mu wskazówek dla dalszego przekszta³cania.

\section{Aparat matematyczny \zet}

Przekszta³canie predykatu do mo¿liwie najprostszej postaci w systemie 
{\bf Z/EVES} wykorzystuje wbudowany w maszynê dowodzenia rachunek zdañ.
W niej równie¿ zaimplementowane s± niektóre podstawowe twierdzenia i 
mechanizmy (np. regu³y równowa¿no¶ci lub dzia³ania arytmetyczne). Jednak¿e 
w wiêkszo¶ci przypadków sama logika nie jest wystarczaj±ca do pomy¶lnego 
przeprowadzenia dowodu, potrzebna jest równie¿ wiedza na temat w³a¶ciwo¶ci 
wykorzystywanych konstrukcji matematycznych, takich jak relacje, zbiory lub 
sekwencje. Poniewa¿ wiedza ta jest obszerna i ich implementacja w rdzeniu systemu
nastrêcza³aby wiele trudno¶ci, jednocze¶nie uniemo¿liwiaj±c jej stopniow±
rozbudowê, autorzy systemu postanowili umie¶ciæ pozosta³e twierdzenia i
teorematy w postaci zbioru regu³, zwanym te¿ aparatem matematycznym systemu
(ang. {\it mathematical toolkit}). Jest on szczegó³owo udokumentowany w
\cite{Z-EVES-MT}.

Najwa¿niejsz± rzecz±, z której powinien zdawaæ sobie sprawê u¿ytkownik jest
fakt, ¿e nie wszystkie twierdzenia i w³a¶ciwo¶ci dotycz±ce konkretnych
elementów aparatu matematycznego mog± byæ przydatne do przeprowadzenia
dowodu. Dzieje siê tak z ró¿nych powodów, najczê¶ciej zastosowanie
niew³a¶ciwych twierdzeñ powoduje niepotrzebne skomplikowanie predykatu
docelowego, które prowadzi donik±d, natomiast zaciemnia istotne fakty mog±ce
naprowadziæ u¿ytkownika na w³a¶ciwy plan dowodu. Dlatego czê¶æ twierdzeñ
jest oznaczona w {\it mathematical toolkit} jako regu³y wy³±czone (ang. {\it
disabled rules}). S± one znane {\bf Z/EVES} jako prawdziwe, ale nie s±
wykorzystywane w automatycznej strategii dowodzenia. Niemniej znajomo¶æ tych
faktów jest czêsto niezbêdna dla pomy¶lnego dowodu w przypadku, kiedy system
nie mo¿e zakoñczyæ go automatycznie. Przyk³adem mo¿e byæ sprawdzanie
równo¶ci zbiorów i regu³a {\it extensionality}:

\begin{theorem}{disabled rule extensionality}
	X = Y \iff (\forall x : X @ x \in Y) \land (\forall y : Y @ y \in X)
\end{theorem}

\begin{theorem}{disabled rule extensionality2}
	X = Y \iff X \in \power Y \land Y \in \power X
\end{theorem}

Gdyby jedna z tych regu³ by³a w³±czona automatycznie, to system zamienia³by ka¿de
wyst±pienie znaku równo¶ci na predykat po prawej stronie równowa¿no¶ci
($\iff$), co oczywi¶cie jest w wiêkszo¶ci wypadków niepo¿±dane.

% moze kiedys...
%
%\subsection{Regu³y wy³±czone}
%\subsection{Definicje uogólnione}
%\subsection{Rozszerzalno¶æ}
%\subsection{Strategtie automatyzacji}
%\subsubsection{Os³abianie}
%\subsubsection{Regu³y obliczeniowe}
%\subsubsection{Regu³y idealne}

%z Toolkitu:
%- do czego s± disabled rules
%- generic definitions
%- extensionality
%- automation strategies
%	- weakening
%	- computation rules
%	- ideal rules

\section{Metody i algorytmy automatycznego przeprowadzania dowodów}

\subsection{Analiza wyra¿enia i normalizacja}

W {\bf Z/EVES} dostêpne s± trzy komendy ({\bf simplify, rewrite, reduce}), 
które potrafi± zredukowaæ wyra¿enie. Analizuj± je one od lewej do prawej 
strony, z góry do do³u. Ka¿da czê¶æ jest rozwa¿ana i ewentualnie zastêpowana 
przez nowe wyra¿enie. Podczas analizy utrzymywany jest {\it kontekst}, który
jest zbiorem predykatów zak³adanych jako prawdziwe. Przyk³adowo, podczas
analizowania predykatu w formie $P \cap Q \implies R$ :

\begin{itemize}
\item{} $P$ jest rozwa¿ane i ew. zastêpowane przez $P'$,
\item{} z za³o¿eniem, ¿e $P$ jest prawdziwe, rozwa¿ane jest $Q$ i ew.
zastêpowane przez $Q'$
\item{} z za³o¿eniem, ¿e $P$ i $Q$ s± prawdziwe, rozwa¿ane jest $R$ ew.
zastêpowane przez $R'$
\item{} wynikiem jest $P' \cap Q' \implies R'$. Je¿eli jeden lub wiêcej
nowych predykatów to {\it true} lub {\it false}, to mog± byæ wtedy
wyeliminowane, lub nawet ca³e wyra¿enie jest redukowany do {\it true} lub {\it
false}.
\end{itemize}

Te trzy komendy ró¿ni± siê miedzy sob± sposobem `rozwa¿ania' wyra¿enia.

Czasami domy¶lna metoda wnioskowania {\bf Z/EVES} nie jest w stanie
przetworzyæ wyra¿enia. Przyk³adowo dla predykatu

\begin{zed}
\t1	(P \lor Q) \\
\t1	\land (P \implies R) \\
\t1	\land (Q \implies R)
\end{zed}

system nie jest w stanie skonkludowaæ predykatu $R$.

W takich wypadkach dostêpne jest bardziej potê¿ne narzêdzie wnioskuj±ce,
czyli normalizacja. Je¶li jest w³±czona i system napotka w wyra¿eniu relacjê
logiczn± zag³êbion± w innej, to rozwa¿ane s± wtedy wszystkie przypadki.
Przyk³adowo predykat $(P \lor Q) \land R$ jest zamieniany do postaci 
{\bf if} $P$ {\bf then} $R$ {\bf else} $(Q \land R)$. Predykat $R$ jest
rozwa¿any dwukrotnie, raz z za³o¿onym $P$, drugi raz z wykluczonym $P$ i
za³o¿onym $Q$. Normalizacja jest domy¶lnie wy³±czona, poniewa¿ poprzez
powtarzanie czê¶ci predykatu, jej u¿ycie prowadzi czêsto do bardzo d³ugich 
wyra¿eñ docelowych. Jednak¿e zwiêksza ona moc maszyny dowodzenia.

\subsection{Upraszczanie}

Dla upraszczania wyra¿eñ, w po³±czeniu z analiz± opisan± w poprzednim
punkcie, stosuje siê kilka metod, jak np. sprawdzanie równo¶ci arytmetycznych, 
kontrolowanie tautologii i równowa¿no¶ci w sensie rachunku zdañ, oraz aplikowanie 
regu³ przekazuj±cych {\it (ang. forward rule)} i regu³ za³o¿eñ {\it (ang. assumption
rule)}.

\subsubsection{Rachunek zdañ}

Twierdzenia i zale¿no¶ci rachunku zdañ {\it (ang. propositional logic)} s±
wykorzystywane w ró¿nych czê¶ciach maszyny dowodzenia, tzn. w analizie
wyra¿enia, normalizacji i przekszta³caniu.

Jak ju¿ by³o wspomniane wcze¶niej, analizie wyra¿enia towarzyszy {\it
kontekst}. Je¶li dany predykat jest w kontek¶cie za³o¿ony jako {\it true}
lub {\it false}, to wszystkie jego wyst±pienia w badanym wyra¿eniu s±
zamieniane odpowiednio na {\it true} lub {\it false}, a nastêpnie nowe
wyra¿enie jest przekszta³cane poprzez usuniêcie redundantnych czê¶ci. Np.
$x = 1 \land$ {\it true} jest zamieniane na $x = 1$, a $x > 2 \implies$ {\it
true} na {\it true}. Predykat $x \in S \implies x \in S$ jest rozpatrywany w
dwóch krokach: najpierw $x \in S$ jest dodawane do {\it kontekstu} i
predykat jest sprowadzany do postaci $x \in S \implies$ {\it true}, a potem
z rachunku zdañ do {\it true}.

Mechanizm ten pozwala na rozpoznanie wiêkszo¶ci tautologii, je¶li w³±czona
jest normalizacja, {\bf Z/EVES} obs³uguje wszystkie tautologie.

\subsubsection{Równowa¿no¶æ}

Równowa¿no¶ci {\it (ang. equalities)} s± traktowane w specjalny sposób,
zaimplementowany automat decyzyjny wyra¿enia takie jak $a = a$,
$a = b \implies b = a$, $X = Y \implies \power X = \power Y$ rozpoznaje
jako prawdziwe.

\subsubsection{Regu³y arytmetyczne}

Algorytm upraszczaj±cy potrafi sobie radziæ z podstawowymi dzia³aniami
i relacjami arytmetycznymi, np. wie ¿e wyra¿enie $1 < 2$ jest prawdziwe, a
$2*2 > 3+4$ - nie. Regu³y arytmetyczne s± w³±czane dla wyra¿enia $t$, je¶li w 
{\it kontek¶cie} znajduje siê predykat $t \in \num$. Oprócz liczb
obs³ugiwane s± równie¿ liniowe wyra¿enia algebraiczne, np. 
$\forall x, y : \num | 1 \leq x \land 2 + 3 * x \leq y @ 5 \leq y$ jest
sprowadzane do {\it true}.

\subsubsection{Regu³y za³o¿eñ}

System {\bf Z/EVES} pozwala na definiowanie tzw. regu³ za³o¿eñ {\it (ang.
assumption rule)}, które s± teorematami oznaczonymi s³owem kluczowym 
{\tt grule}. Jest to regu³a `wyzwalana' {\it (ang. triggered)} predykatem.
Podczas analizy, je¶li system podczas rozwa¿ania jakiego¶ wyra¿enia napotka
na wyst±pienie predykatu `wyzwalaj±cego' jakiej¶ regu³y, to regu³a zostanie
zastosowana.

`Stosowanie' regu³y zale¿y od jej postaci. Je¶li to nie jest implikacja, jej
predykat zostanie dodany do {\it kontekstu}. Je¶li ma ona postaæ warunkow±,
to wtedy badane jest spe³nienie tego warunku, poprzez sprawdzenie, czy nie
wystêpuje zaprzeczenie zak³adaj±c ¿e regu³a jest nieprawdziwa (ma warto¶æ
{\it false}). Po pozytywnym zweryfikowaniu warunku, predykat regu³y dodawany
jest do kontekstu.

{\bf Z/EVES} automatycznie generuje za³o¿enia, podczas sprawdzania kolejnych
paragrafów. Regu³y te s± u¿yteczne we wspomaganiu dowodzenia arytmetycznych 
w³a¶ciwo¶ci zmiennych. Przyk³adowo:

\begin{axdef}
	maxLength : \nat_1
\end{axdef}

Po zdefiniowaniu takiego aksjomatu automatycznie jest generowana regu³a \\
$maxLength\$declaration$, zawieraj±ca warunek $maxLength \in \nat_1$.
Podczas przekszta³cania predykat ten wspó³dzia³a z tzw. regu³ami
uogólniaj±cymi z aparatu matematycznego systemu, które m.in. stanowi±, ¿e
$\nat_1 \in \power \nat$, co pozwala na stwierdzenie, ¿e np. 
$maxLength \in \nat$ lub $maxLength \in \num$ s± prawdziwe. Proces
`upraszczania' nie ma jednak danych na temat liczb naturalnych, zatem próba
udowodnienia

\begin{zed}
	\forall x : \num @ x + maxLength > x
\end{zed}

zakoñczy siê niepowodzeniem. Mo¿emy zatem pomóc poprzez dodanie
odpowiedniego teorematu:

\begin{theorem}{grule maxLengthBound}
	maxLength \geq 1
\end{theorem}

System napotkawszy definicjê $maxLength$ automatycznie doda fakt, ¿e
$maxLength \geq 1$, co sprawia, ¿e upraszczanie jest w stanie udowodniæ
proste fakty arytmetyczne, jak np. $maxLength + maxLength \geq 2$.

\subsubsection{Regu³y przekazuj±ce}

Wspomniany wcze¶niej {\it kontekst} jest zbiorem predykatów zak³adanych jako
prawdziwe. Kiedy predykat jest dodawany do kontekstu, mo¿e spowodowaæ to
zastosowanie kolejnej `wyzwalanej' regu³y - czyli regu³y przekazuj±cej {\it
(ang. forward rule)}. 

Jest to teoremat w formie $P \implies Q$, który jest oznaczony s³owem
kluczowym {\tt frule}. Je¶li dodawany do {\it kontekstu} predykat wystêpuje
dla jakiej¶ regu³y jako instancja $P$, wtedy równie¿ $Q$ jest dodawane do
kontekstu.

Podobnie jak regu³y za³o¿eñ, regu³y przekazuj±ce s± automatycznie generowane
przez system podczas deklarowania schematów. Dla schematu 
$S \defs [x,y : \num | x < y]$ ta regu³a to 
$S \implies x \in \num \land y \in \num$. Zatem, kiedy zak³adana jest
prawdziwo¶æ $S$, typy jego komponentów $x, y$ s± znane i dodawane do {\it
kontekstu}.

\subsection{Przekszta³canie}

Przekszta³canie {\it (ang. rewriting)} to nastêpna z trzech metod
operacji na predykatach przez system {\bf Z/EVES}. Jest to osi±gane
poprzez upraszczanie wyra¿enia oraz stosowanie regu³ przekszta³ceñ {\it (ang.
rewriting rules)}. Regu³a taka ma postaæ $Warunek \implies Wzorzec = Zamiennik$ 
(lub $Warunek \implies Wzorzec \iff Zamiennik$). Do jej wywo³ania s³u¿y
komenda {\tt reduce}. Przyk³adowe regu³y przekszta³ceñ:

\begin{theorem}{rule inRange}
	\forall a,b : \num @ x \in a \upto b \iff a \leq x \leq b
\end{theorem}

(warunek to $a \in \num \land b \in \num$, wzorzec $x \in a \upto b$, 
zamiennik $a \leq x \leq b$),

\begin{theorem}{rule ranSeqInPower [X]}
	\forall s : \seq X @ \ran s \in \power Y \iff s \in \seq Y
\end{theorem}

(warunek - $s \in \seq X$, wzorzec - $\ran s \in \power Y$, zamiennik 
$s \in \seq Y$).

Regu³y przekszta³ceñ s± naj³atwiejsze w u¿yciu, poniewa¿ nie maj±
takich sk³adniowych ograniczeñ jak regu³y za³o¿eñ lub przekazuj±ce. Mog± byæ
one zastosowane ¶wiadomie przez u¿ytkownika za pomoc± komendy {\tt apply}.
S± one czêsto domy¶lnie wy³±czone, jak np.:

\begin{theorem}{disabled rule extensionality}
	X = Y \iff (\forall x : X @ x \in Y) \land (\forall y : Y @ y \in X)
\end{theorem}

Gdyby ta regu³a by³a domy¶lnie w³±czona, to ka¿da równo¶æ w wyra¿eniu by³aby
zastêpowana sprawdzaniem zawierania siê elementów. Jest ona jednak potrzebna
do udowodnienia $(1 \upto 5) \cap (3 \upto 7) = (3 \upto 5)$, poniewa¿
redukcja nie potrafi sobie z tym poradziæ.

Interfejs graficzny programu pozwala na informowanie u¿ytkownika o
wy³±czonych regu³ach przekszta³ceñ, je¿eli warunek jakiej¶ regu³y jest
spe³niony dla danego predykatu, to jej nazwa pojawia siê po jego
zaznaczeniu.

\subsection{Redukcja}

Redukcja {\it (ang. reduction)}, wywo³ywana komend± {\tt reduce}, wykorzystuje
dwie poprzednie metody - tzn. upraszczanie i przekszta³canie.  Jej dzia³anie
polega na sprawdzaniu podczas analizy, czy pod-predykat lub pod-wyra¿enie
nie jest odwo³aniem do innej definicji lub schematu.  Je¶li jest, to
referencja zamieniana jest na oryginaln± definicjê, która zostaje wstawiona
do badanej formu³y. Ca³e wyra¿enie jest wtedy upraszczane i redukowane od
pocz±tku, proces ten powtarza siê do momentu, kiedy nie ma ju¿ referencji do
innych schematów. W kroku pêtli stosowane s± równie¿ regu³y przekszta³ceñ, o
ile ich warunek jest spe³niony.

Jest to wygodna metoda, je¶li chcemy pozbyæ siê wszelkich zewnêtrznych
definicji i skupiæ siê na samym wyra¿eniu docelowym. Czêsto koñczy siê
powodzeniem, ale nie zawsze jest polecana. Szczególnie w wypadku, kiedy mamy
do czynienia z wieloma schematami, d³ugimi definicjami, których substytucja
w miejsce referencji nie zawsze jest pomocna i nie ma wp³ywu na dowód. W
takim wypadku zastosowanie redukcji ograniczy znacznie czytelno¶æ dowodu,
poniewa¿ w miejsce krótkich wyra¿eñ identyfikuj±cych inne schematy zostan±
wstawione ich rozwiniêcia (definicje), czego rezultatem jest d³ugie i 
nieczytelne wyra¿enie, trudne do zrozumienia.

Aby tego unikn±c, dostêpne s± dwie metody. Pierwsza polega na podzieleniu
dowodu na kilka mniejszych, ³atwo czytelnych teorematów, które udowodnione
wcze¶niej spowoduj± wiêksz± czytelno¶æ i ³atwiejsze zarz±dzanie procesem
dowodzenia. Druga, to stosowanie komendy {\tt invoke}, która polega na
zamianie wybranego odwo³ania na jego definicjê, co pozwala na efektywne
sterowanie rozwiniêciami wyra¿eñ.

\subsection{Pêtle dowodu}

Komendy {\bf Z/EVES}, które pozwalaj± na najwiêkszy poziom automatyzacji
dowodzenia to {\tt prove} i {\tt prove by reduce}. Ich wywo³anie powoduje
wykonanie przez system typowych sekwencji innych komend. Uruchomiona pêtla
przerywana zostaje, kiedy dowód jest zakoñczony, lub nie ma dalszych
postêpów. 

Inne u¿yteczne komendy, to {\tt prenex}, które w miarê mo¿liwo¶ci eliminuje 
kwantyfikatory, {\tt rearrange} u¿ywane w celu przeorganizowania predykatu
prostsze fakty przesuwaj±c na pocz±tek wyra¿enia, oraz {\tt equality
substitution} aplikuj±ce specjalne mechanizmy wykrywania równo¶ci i
równowa¿no¶ci.

\subsection{Podstawienie}

W niektórych wypadkach zdarza siê, ¿e w zdaniu logicznym wystêpuje kwantyfikator
$\exists$ i system nie jest w stanie przekszta³ciæ takiego predykatu, chocia¿
oczywisty jest przypadek spe³niaj±cy dane za³o¿enia. Je¶li komenda {\tt
prenex} nie potrafi zlikwidowaæ kwantyfikatorów, do dyspozycji u¿ytkownika 
dostêpna jest jeszcze komenda podstawienia {\it (ang. instantiation)},
która umo¿liwia wyspecyfikowanie i podstawienie jakiej¶ warto¶ci pod zmienn±
lub czê¶æ wyra¿enia. Odbywa siê to w/g nastêpuj±cej regu³y - maj±c dany predykat:

\begin{zed}
	\exists x : S @ P(x)
\end{zed}

podstawienie $x$ do $e$ przekszta³ca go do 

\begin{zed}
	(e \in S \land P(e)) \lor \exists x : S @ P(x)
\end{zed}

Ta regu³a jest stosowana w celu zapewnienia równowa¿no¶ci pocz±tkowego
wyra¿enia docelowego z koñcowym. Przyk³adowo

\begin{zed}
\t1	k \in \num \land k \geq 0 \\
\implies (\exists n : \nat @ k = n \lor k < 1 \land n < 1)
\end{zed}

{\bf Z/EVES} nie potrafi znale¼æ w³a¶ciwej warto¶ci dla $n$, choæ oczywiste
jest ¿e $n = 0$ spe³nia warunek kwantyfikatora. Mo¿emy wiêc pomóc mu komend± 
{\bf instantiate n == 0}. Prowadzi to do

\begin{zed}
\t1	k \in \num \land k \geq 0 \\
\t1	\land \lnot (0 \in \nat \land (k = 0 \lor k < 1 \land 0 < 1)) \\
\implies (\exists n : \num @ k = n \lor k < 1 \land n < 1)
\end{zed}

co mo¿e ju¿ byæ udowodnione komend± {\bf prove}. Dodatkowo system przekszta³ci³ 
zdanie typu $P \implies Q \lor R$ do $P \land \lnot Q \implies R$.


\section{Planowanie dowodu}

Pomimo faktu, ¿e {\bf Z/EVES} jest w chwili obecnej najbardziej
zautomatyzowanym narzêdziem wspomagaj±cym przeprowadzanie dowodów, w wypadku
bardziej skomplikowanych teorematów musimy mu pomóc, poprzez podanie zarysu
dowodu. Interwencja u¿ytkownika potrzebna te¿ jest je¶li mechanizmy maszyny
dowodzenia przekszta³caj± predykat w wyra¿enie trudno zrozumia³e i nie mog±
doprowadziæ go do koñca, podczas gdy wystarczy zmieniæ jeden z kroków
pocz±tkowych, aby dowód sta³ siê prosty. Niestety wymaga to pewnego
do¶wiadczenia oraz dobrej znajomo¶ci aparatu matematycznego i jego
twierdzeñ, dostarczanego razem z systemem (patrz \cite{Z-EVES-MT}).

We¼my nastêpuj±cy przyk³ad:

\begin{theorem}{example}[X, Y, Z]
	\forall Q : X \rel Y; R : Y \rel Z; S : \power Y @ \\
\t1		(Q \rres S) \comp R = Q \comp (S \dres R)
\end{theorem}

Na dowód tego teorematu sk³adaj± siê nastêpuj±ce kroki:

\begin{enumerate}
\item{} $Q \rres S = Q \comp \id S$ - ze znanego teorematu $compIdRight$ z aparatu matematycznego pakietu.
\item{} Po podstawieniu mamy: $(Q \rres S) \comp R = (Q \comp \id S) \comp R$.
\item{} $(Q \comp \id S) \comp R = Q \comp (\id S \comp R)$ - ze znanego teorematu $compAssociates$.
\item{} $\id S \comp R = S \dres R$ - ze znanego teorematu $compIdLeft$.
\item{} Po podstawieniu mamy: $Q \comp (\id S \comp R) = Q \comp (S \dres R)$.
\item{} $(Q \rres S) \comp R = Q \comp (S \dres R)$ z (2), (3) i (5).
\end{enumerate}

Podstawienia (2) i (5) mog± byæ przeprowadzone automatycznie przez system
dziêki regu³om równo¶ci mechanizmu upraszczania. U¿ytkownik znaj±c ten dowód
mo¿e wskazaæ systemowi u¿ycie w³a¶ciwych teorematów z aparatu
matematycznego. S³u¿y do tego komenda {\tt use}. Plan dowodu {\bf Z/EVES}
wygl±da zatem nastêpuj±co:

\begin{zproof}
use compIdRight[X, Y][R := Q];
use compAssociates[X, Y, Y, Z][P := Q, Q := \id S];
use compIdLeft[Y, Z];
prove;
\end{zproof}

\section{Przyk³ad - dowodzenie w³a¶ciwo¶ci ECSM}

Przedstawiê teraz przyk³ad praktycznego u¿ycia systemu {\bf Z/EVES} do
udowodnienia w³a¶ciwo¶ci niedeterministycznego automatu skoñczonego, w 
tym przypadku ECSM.  Podany sposób mo¿e byæ wykorzystany do opisu 
dowolnego automatu skoñczonego, oraz jako przyk³ad wej¶ciowy do próby 
udowodnienia jego w³asno¶ci.

Rysunek  \ref{fig:ecsm_rys1} przedstawia generator odwo³añ do bufora, którego
pojemno¶æ wynosi $N$. 

\begin{figure}[pt]
\centering
\begin{picture}(470.00,220.00)
\put(-5.00,-10.00){\framebox(470.00,220.00){}}
\includegraphics{figures/ecsm_rys1}
\end{picture}
  \caption{Model ECSM generatora komunikatów {\bf put} i {\bf get}}
  \label{fig:ecsm_rys1}
\end{figure}
Generator jest skonstruowany tak, aby nie przepe³ni³ bufora, ani nie próbowa³ 
pobieraæ z bufora pustego, dla znanego $N$. Komunikaty {\it put} i {\it get}
s± generowane niederministycznie, ale tylko wtedy, gdy bufor jest gotowy do
przyjêcia zlecenia, czyli znacznik zajêto¶ci $r$ nie jest ustawiony 
($\neq 1$).

Warunkiem poprawno¶ci jest wiêc, ¿e `nigdy nie jest tak, ¿e $g > N$'.
`Nigdy' mo¿na rozumieæ jako `na ¿adnej ¶cie¿ce w grafie osi±galno¶ci (RG)'
lub `w ¿adnym stanie RG'. Na gruncie modeli skoñczenie-stanowych, je¶li $N$
jest {\it konkretne i znane}, badanie tego warunku poprawno¶ci mo¿na
przeprowadziæ w grafie RG, utworzonym jako produkt grafu sterowania CSM jak
na rys. \ref{fig:ecsm_rys2} i grafu CSM zachowañ danej - jak na rys.
\ref{fig:ecsm_rys3}.

\begin{figure}[pt]
\centering
\begin{picture}(300.00,220.00)
\put(-5.00,-10.00){\framebox(300.00,220.00){}}
\includegraphics{figures/ecsm_rys2}
\end{picture}
  \caption{Model ECSM sprowadzony do CSM}
  \label{fig:ecsm_rys2}
\end{figure}

Model zachowania z rys. \ref{fig:ecsm_rys1} sprowadzono do postaci CSM,
zastêpuj±c warunki $g > 0$ i $g < N$ przez wystêpowanie lub nie wystêpowanie
sygna³ów $c1$, $c2$, generowanych przez model zmiennej $g$.

\begin{figure}[pt]
\centering
\begin{picture}(400.00,100.00)
\put(-5.00,-10.00){\framebox(400.00,100.00){}}
\includegraphics{figures/ecsm_rys3}
\end{picture}
  \caption{Model CSM zachowañ zmiennej {\bf g}}
  \label{fig:ecsm_rys3}
\end{figure}

Spróbujemy podej¶æ do problemu, opisuj±c graf za pomoc± logiki \zet i
wprowadzaj±c do tego opisu narzêdzia rachunku predykatów. Musimy wiêc
udowodniæ, ¿e dla dowolnego $N \geq 1$ warto¶æ $g$ nie przekracza $N$.
Nie zak³adamy ju¿, ¿e $N$ jest {\it konkretne i znane}, ale przyjmujemy ¿e
$N \in \nat$, a zatem automat jest skoñczony.

Zdefiniujmy bufor $Buffer$ o pojemno¶ci $N$, wraz ze wska¼nikiem zajêto¶ci bufora $r$.

\begin{schema}{Buffer}
	N, r : \nat
\where
	N > 0
\end{schema} 

Maj±c bufor, potrzebna jest nam przestrzeñ stanów generatora i zwi±zany z
ni± znacznik $g$ bufora. Definiujemy 4 stany - zmienna $state$ mo¿e
znajdowaæ siê w zakresie $1 \upto 4$.

\begin{schema}{States}
	state, g : \nat
\where
	state \in 1 \upto 4
\end{schema} 

£±czymy oba te schematy w jedn± ca³o¶æ otrzymuj±c definicjê $Automat$. Jest
to przyk³ad koniunkcji dwóch schematów.

\begin{zed} Automat \defs Buffer \land States \end{zed}

Operacja $AutomatInit$ okre¶la pocz±tkowy stan automatu. 

\begin{schema}{AutomatInit}
	Automat
\where
	state = 1 \\
	g = 0 \\
	r = 1 \\
	N = 10
\end{schema} 

W rzeczywistym systemie bufor ma zawsze ograniczony rozmiar, w $AutomatInit$
ustalamy $N = 10$, chocia¿ $N$ mo¿e byæ dowoln± liczb± dodatni±.

Kolejne operacje bêd± okre¶la³y mo¿liwe przej¶cia z poszczególnych stanów
automatu. W ten sposób faktycznie opisujemy automat za pomoc± modelu \zet.
Wska¼nik zajêto¶ci $r$ jest nieistotny z punktu widzenia w³a¶ciwo¶ci, któr±
chcemy udowodniæ, pomijamy go wiêc w opisie.
Operacja przej¶cia ze stanu 1 do 1:

\begin{schema}{Op1to1}
	\Delta Automat
\where
	state' = 1 \\
	g' = g
\end{schema} 

oraz z 1 do 2:

\begin{schema}{Op1to2}
	\Delta Automat
\where
	state' = 2 \\
	g' = g
\end{schema} 

Operacja $GoFromState1$ okre¶la warunek przej¶cia ze stanu 1. Z tego ¿e
automat jest w stanie 1, wynika ¿e przejdzie on do stanu 1 lub 2.
Nale¿y zauwa¿yæ, ¿e u¿yta jest tu alternatywa, a wiêc nie jest pewne czy 
po przej¶ciu automat bêdzie w stanie 2, czy te¿ nadal w stanie 1 - 
opisujemy wiêc w ten sposób niedeterminizm operacji.

\begin{schema}{GoFromState1}
	\Delta Automat
\where
	state = 1 \implies Op1to1 \lor Op1to2
\end{schema} 

Analogicznie operacje przej¶æ ze stanu 2:

\begin{schema}{Op2to2}
	\Delta Automat
\where
	r \neq 1 \implies state' = 2 \\
	g' = g
\end{schema} 

\begin{schema}{Op2to3}
	\Delta Automat
\where
	g < N \land state' = 3 \land g' = g + 1
\end{schema} 

\begin{schema}{Op2to4}
	\Delta Automat
\where
	g > 0 \land state' = 4 \land g' = g - 1
\end{schema} 

Operacja $GoFromState2$ opisuje warunki wyj¶cia ze stanu 2, analogicznie do
poprzedniego stanu:

\begin{schema}{GoFromState2}
	\Delta Automat
\where
	state = 2 \implies Op2to2 \lor Op2to3 \lor Op2to4
\end{schema} 

Operacje przej¶cia ze stanu 3:

\begin{schema}{Op3to1}
	\Delta Automat
\where
	state' = 1 \\
	g' = g
\end{schema} 

\begin{schema}{GoFromState3}
	\Delta Automat
\where
	state = 3 \implies Op3to1
\end{schema} 

I ze stanu 4:

\begin{schema}{Op4to1}
	\Delta Automat
\where
	state' = 1 \\
	g' = g
\end{schema} 

\begin{schema}{GoFromState4}
	\Delta Automat
\where
	state = 4 \implies Op4to1
\end{schema} 

Opisali¶my ju¿ ca³y automat, teraz potrzebujemy formalnego po³±czenia tych
opisów. Schemat $GoState$ sumuje znane fakty, okre¶laj±c mo¿liwe operacje na
przestrzeni stanów automatu. Operacja ta symbolizuje zatem jedno przej¶cie
automatu.

\begin{schema}{GoState}
	\Delta Automat
\where
	state = 1 \implies GoFromState1 \\
	\lor state = 2 \implies GoFromState2 \\
	\lor state = 3 \implies GoFromState3 \\
	\lor state = 4 \implies GoFromState4
\end{schema} 

Teraz mo¿emy przej¶æ do dowodzenia w³a¶ciwo¶ci generatora. Najpierw
standardowy teoremat dowodz±cy osi±galno¶æ pocz±tkowego stanu generatora:

\begin{theorem}{canInitAutomat}
	\exists Automat @ AutomatInit
\end{theorem}

Dowód jego w³a¶ciwo¶ci {\bf Z/EVES} potrafi przeprowadziæ automatycznie:

\begin{zproof}
	prove by reduce
\end{zproof}

I koñcowy teoremat reprezentuj±cy w³a¶ciwo¶æ, któr± chcieli¶my dowie¶æ na
pocz±tku. $gNoMoreThanN$ mówi, ¿e ani operacja pocz±tkowa $AutomatInit$,
ani przej¶cie z dowolnego stanu nie spowoduj±, ¿e $g > N$. Czyli `nigdy g
nie przekracza $N$'.

\begin{theorem}{gNoMoreThanN}
	(AutomatInit \implies \lnot g > N) \land (GoState \land \lnot g > N 
	\implies \lnot g' > N)
\end{theorem}

Dowód mo¿e byæ przeprowadzony automatycznie, za pomoc± redukcji z w³±czon±
normalizacj±.

\begin{zproof}
	with normalization reduce
\end{zproof}

Wykazali¶my zatem w³a¶ciwo¶æ automatu za pomoc± pojêæ dostêpnych w notacji
Z, oraz maszyny dowodzenia systemu {\bf Z/EVES}. Przyk³ad jest dosyæ prosty,
jego wad± jest jednak ograniczenie do skoñczonej przestrzeni stanów,
mo¿e te¿ raziæ opisem ca³ego automatu i wszystkich jego przej¶æ. W 
rzeczywistej specyfikacji powinny byæ umieszczone fakty, na których nam 
zale¿y ¿eby je opisaæ lub udowodniæ, natomiast rzeczy mniej wa¿ne i nieistotne 
z punktu widzenia funkcjonalno¶ci powinny byæ pominiête. Mo¿na w 
ten sposób zapewniæ pole manewru programistom, nie narzucaj±c im sztywnych
ram dzia³añ, a jednocze¶nie zapewniaj±c niezbêdny formalizm ca³ego
przedsiêwziêcia.

\section{Uwagi praktyczne}

{\bf Z/EVES} jest bardzo rozbudowanym programem, z niespotykanymi mo¿liwo¶ciami
automatycznego przeprowadzania dowodów. Niestety jest to jednak narzêdzie przydatne
w tej chwili bardziej naukowcom, ani¿eli projektantom komercyjnych projektów.
Dzieje siê tak z kilku powodów:

\begin{itemize}

\item{} Brakuje bardziej zaawansowanego zarz±dzania projektem, poniewa¿ wszystkie
fakty musz± byæ zawarte w jednym dokumencie. Nie mo¿na rozproszyæ specyfikacji na
niezale¿ne sekcje, co w przypadku wiêkszych przedsiêwziêæ stanowi oczywist± trudno¶æ.

\item{} Automatyczne dowodzenie, choæ bardzo dobrze rozwi±zane, dzia³a niestety 
tylko dla prostszych dowodów. Zazwyczaj konieczna jest interwencja projektanta,
który musi przygotowaæ odpowiedni {/it proof script}. Ustalanie strategii dowodu
jest zajêciem niebanalnym, oprócz doskona³ej znajomo¶ci logiki i aparatu matematycznego
wymagane jest zrozumienie konstrukcji wbudowanego {/it toolkitu} \zet, a tak¿e 
wiedza, w jaki sposób dzia³a {/it Z/EVES}. W praktyce projektant musi mieæ du¿e 
do¶wiadczenie, nawet gdy stosowane zapisy /zet s± na ¶rednim poziomie trudno¶ci.

\item{} Toolkit i wiedza matematyczna zakodowana w {/bf Z/EVES} ograniczaj± siê
jedynie do podstawowych pojêæ notacji. W praktyce wiêkszo¶æ problemów, z jakimi
borykaj± siê projektanci jest typowa, brakuje wiêc czego¶, co pe³ni³o by rolê
biblioteki standardowej, opisuj±cej klasy problemów. Przyk³adami takich klas
problemów s± liczby zmiennoprzecinkowe, definicje znane z baz danych (tabela,
indeks, klucz), pliki lub przetwarzanie równoleg³e (synchronizacja, semafor, w±tek).

\end{itemize}

\chapter{Standard ISO}

W lipcu 2002 roku, po ponad 8 latach prac, powsta³a pierwsza edycja
miêdzynarodowego standardu ISO/IEC 13568.

Historiê standaryzacji notacji \zet rozpoczyna ukazanie siê w 1989
pierwszego wydania referencji jêzyka J. M. Spivey'a (\cite{Spivey-ZRM}).
Ksi±¿ka by³a prze³omem w ustaleniu postaci notacji, w której mniej wiêcej
przetrwa³a do dzisiaj. Praca ta sta³a siê nieformalnym standardem, na którym
bazuje wiêkszo¶æ publikacji, jak równie¿ narzêdzi do sprawdzania sk³adni i
typów.

Nastêpnym krokiem by³o rozpoczêcie procesu standaryzacji \zet zgodnie z
zaleceniami organizacji ISO. Proces ten przewiduje cztery fazy ewoluowania
dokumentów. Pierwsza, czyli {\it Working Drafts} obejmuje dokumenty, które
s± tworzone oraz sprawdzane przez cz³onków panelu. Nastêpuje po tym faza 
{\it Committee Drafts} - które s± podane do publicznej wiadomo¶ci. Jest to
czas debaty, w wyniku której powstaje finalna wersja dokumentu.
Koñcowy CD dla \zet zosta³ zatwierdzony 25.08.1999. Trzeci etap to s± ju¿
wstêpne wersje standardu, do których wprowadza siê tylko zmiany koryguj±ce
wykryte b³êdy i nie¶cis³o¶ci. Dokument o nazwie {\it Draft International
Standard} zosta³ zaaprobowany 28.04.2002, w stosunku do finalnego CD
zawiera³ tylko drobne zmiany dotycz±ce kodowania Unicode. Wersja ta
oczekiwa³a na akceptacjê do 04.07.2002, czego wynikiem jest gotowy i 
opublikowany {\it International Standard}, dostêpny poprzez cia³o
standaryzacyjne.

\section{Struktura standardu}

Standard wprowadza regulacje w nastêpuj±cych dziedzinach:

\begin{itemize}
\item{} sk³adnia \zet
\item{} system typów
\item{} semantyka \zet
\item{} aparat matematyczny i stosowane operatory
\item{} jêzyk typu {\it mark-up} do zapisu notacji w trybie {\tt ASCII}
\end{itemize}

W jego sk³ad nie wchodzi opis ¿adnej metodologii stosowania \zet. Za³o¿eniem
jego twórców mia³o byæ jak najpe³niejsze wykorzystanie faktu, ¿e referencja
jêzyka okre¶lona w \cite{Spivey-ZRM} jest najszerzej znanym dokumentem
opisuj±cym tê tematykê. Standard wykorzystuje zatem dorobek tej pracy
powsta³ej 10 lat wcze¶niej, wprowadzaj±c jednak szereg innowacji i poprawek
w miejscach, które nie by³y do koñca zbadane lub przemy¶lane. Pomimo faktu,
¿e wiêksza waga przywi±zywana jest do formalizacji zapisu i sk³adni jêzyka,
to utrzymany jest duch ksi±¿ki Spivey'a, przyk³adowo w sk³ad standardu
wchodzi wprowadzenie (ang. {\it tutorial}) czytelnika w podstawy \zet.

Podstawowym rozszerzeniem wprowadzonym w ISO jest dalsza strukturalizacja
specyfikacji poprzez istnienie {\it sekcji}. Maj± one nazwy i mo¿liwe jest
podanie sekcji nadrzêdnej, zawieraj±cej definicje przydatne w danym
momencie.

\nowalinia section $myspec$ parents $toolkit$
\nowalinia $paragraph_1$
\nowalinia $\dots$
\nowalinia $paragraph_n$
\nowalinia

Jak ju¿ by³o to wspomniane, w podstawowej wersji \zet ka¿da specyfikacja
zaczyna siê w zasiêgu aparatu matematycznego \zet, tzn. dostêpne s± sta³e,
nazwy i typy przez niego wprowadzone. Sekcje natomiast identyfikuj± {\it
otoczenie}, które mo¿e byæ dziedziczone, co pozwala na projektowanie
w³asnych bibliotek \zet i dzielenie du¿ych specyfikacji na komponenty
mo¿liwe do ponownego wykorzystania.

We¼my deklaracje czterech sekcji:

\nowalinia section A
\nowalinia section B parents A
\nowalinia section C parents A
\nowalinia section D parents B,C
\nowalinia 

Dziedziczenie deklaracji po rodzicach przedstawia graf:

\begin{center}
\includegraphics{figures/iso_rys1}
\end{center}

W sekcjach B i C mo¿na u¿ywaæ definicji z sekcji A, natomiast w D -
definicji z A, B, C. W ka¿dym punkcie specyfikacji wa¿ne s± globalne
deklaracje z bie¿±cego kontekstu, oraz z sekcji-przodków.

\section{Aparat matematyczny}

Aparat matematyczny pe³ni funkcjê biblioteki standardowej w klasycznych
jêzykach programowania. Rzeczywiste specyfikacje korzystaj± nie tylko ze
standardowej sk³adni \zet, ale równie¿ z matematycznych rozszerzeñ,
twierdzeñ i faktów towarzysz±cych poszczególnym konstrukcjom. Dlatego oprócz
czê¶ci standardu opisuj±cych sk³adnie i semantykê notacji (np. regu³y
leksykalne czy znaki charakterystyczne \zet) zdefiniowane s± matematyczne
elementy notacji (ang. {\it mathematical toolkit}). Podobnie jak w zwyk³ym
jêzyku programowania korzystamy z funkcji, które s³u¿± np. do operacji na
³añcuchach znakowych lub liczbach, tak w {\bf Standard \zet} dostêpne s±
operatory i zapisy, pozwalaj±ce na korzystanie z sekwencji czy wielozbiorów.

Aparat matematyczny opisany jest w sekcjach, których hierarchia
przedstawiona jest na rys. \ref{fig:iso_rys2}.

\begin{figure}[pt]
\centering
\begin{picture}(220.00,200.00)
\put(-5.00,-10.00){\framebox(220.00,200.00){}}
\includegraphics{figures/iso_rys2}
\end{picture}
  \caption{Hierarchia sekcji aparatu matematycznego {\bf Standard \zet}}
  \label{fig:iso_rys2}
\end{figure}

Podzia³ aparatu matematycznego na sekcje umo¿liwia ich redefiniowanie lub
nawet usuwanie. Przyk³adowo $function\_toolkit$ mo¿e zostaæ pominiête bez
szkody dla wiedzy zdefiniowanej w $number\_toolkit$. Jest to informacja
szczególnie przydatna dla narzêdzi analizuj±cych specyfikacjê \zet.

\section{Rozszerzenia \zet w stosunku do {\bf ZRM}}

Jak ju¿ wspomniano, standard jest rozszerzeniem pracy Spivey'a
\cite{Spivey-ZRM}. W pewnych miejscach jest niekompatybilny z ZRM, w
wiêkszo¶ci przypadków jednak zawiera udogodnienia i innowacje, które
usuwaj± nie¶cis³o¶ci i okre¶laj± brakuj±ce fakty. Punkt ten zawiera
najwa¿niejsze ró¿nice pomiêdzy standardem a \cite{Spivey-ZRM}; w wiêkszo¶ci
jest oparty na pracy Toyna \cite{Toyn_ISO}.

\subsection{Wzajemnie rekursywne typy wolne}

W punkcie \ref{r:free_types} opisano pojêcie typów wolnych oraz zestawienie
narzêdzi matematycznych potrzebnych do ich definicji. To u¿yteczne narzêdzie do
opisu danych, maj±cych charakter rekurencyjny. Jednak dotychczasowy kszta³t \zet
w rozumieniu Spivey'a nie dopuszcza³ jednoczesnego referowania siê przez dwa
ró¿ne typy, czyli wyklucza³ ich wzajemn± rekurencyjno¶æ. Standard ISO \zet usuwa
tê lukê.

Przyk³adowa definicja

\begin{zed}
dec \t1 ::=	Dec \langle\langle name \cross exp \rangle\rangle \\
\& \\
exp \t1 ::=	Let \langle\langle \seq dec \cross exp \rangle\rangle \\
\t2 | Num \langle\langle \nat \rangle\rangle
\end{zed}

ilustruje wzajemn± rekurencyjno¶æ typów wolnych. Definicje typów wzajemnie
rekursywnych musz± byæ opisane w jednym akapicie i po³±czone znakiem $\&$.

Nowa w³a¶ciwo¶æ notacji jest szczególnie przydatna w zastosowaniu \zet do
definicji sk³adni jêzyków.

\subsection{Operatory}

Operator jest jednostk± leksykaln±, która zapisana w specyfikacji musi spe³niaæ
pewne regu³y, np. poprzedzaæ i byæ poprzedzana przez parametry. \zet definiuje
wiele operatorów, a ZRM wprowadza nawet jego pojêcie. Jednak¿e sk³adnia ich
opisu nie by³a okre¶lona; pojêcie i definicja operatora musia³y byæ de facto
zaimplementowane w parserze notacji. Przed standaryzacj± zak³adano, ¿e czytelnik
zna ju¿ znaczenie danego operatora i ich definicje nie mog³y byæ czê¶ci±
specyfikacji. Standard \zet to zmienia. W dokumencie ISO dostêpna jest notacja,
która pozwala na definiowanie operatorów za pomoc± tzw. szablonów. Ich u¿ycie
musi poprzedzaæ okre¶lenie szablonu, który podaje jeden z trzech jego rodzajów:
{\it relation, function, generic}.

Przyk³ady z toolkitu:

\nowalinia relation ( \_ $\neq$ \_ )
\nowalinia function 30 leftassoc ( \_ $\cup$ \_ )
\nowalinia generic 5 rightassoc ( \_ $\iff$ \_ )
\nowalinia relation ( disjoint \_ ) \nowalinia

Szablon rozpoczyna siê nazw± rodzaju operatora, a koñczy jego wzorcem. W ¶rodku, w 
zale¿no¶ci od typu mo¿e znajdowaæ siê liczba oznaczaj±ca pierwszeñstwo, oraz informacja 
o jego ³±czno¶ci.

Za pomoc± nowej sk³adni w toolkicie zdefiniowano w ten sposób wiele operatorów \zet.

\subsection{Hipotezy}

Notacja ZRM wprowadza³a wiele praw, które jednak nie by³y formalnie okre¶lone w sensie
notacji. Narzêdzia dowodu czêsto wprowadzaj± swoje elementy, które umo¿liwiaj± opisanie 
nie tylko praw, ale równie¿ hipotez, docelowych predykatów, teorematów, lematów i 
aksjomatów. Ich sk³adnia jest oczywi¶cie zmienna. Autorzy standardu doszli do wniosku, 
¿e warto sformalizowaæ hipotezy {\it (ang. conjectures)}, gdy¿ s± to elementy bardzo
przydatne do przeprowadzania dowodów. Do tego celu s³u¿y symbol $\models$, po którym nastêpuje
pojedynczy predykat. Pozwala to równie¿ na sformalizowanie praw zawartych w aparacie
matematycznym notacji, np.

\begin{zed}
\models \forall a : \num @ a .. a = \{ a \}
\end{zed}

Oczywi¶cie hipoteza mo¿e byæ b³êdna, chocia¿ poprawna w sensie formalnym zapisu. Przyk³adem
mo¿e byæ:

\begin{zed}
\models 42 \in \{ 1, 2, 3 \}
\end{zed}

Hipotezy najczê¶ciej wykorzystuje siê jako punkty startowe dowodu.

\subsection{Wi±zania i selekcje elementów}\label{r:iso_bindings}

Standardowa notacja \zet dopuszcza³a definiowanie typów danych bêd±cymi iloczynami zbiorów.
Sk³adowe elementu takiego zbioru mog³y byæ nazwane (tzn. istnia³ identyfikator, za pomoc± którego
mo¿na by³o okre¶liæ sk³adow±) lub nienazwane (krotka). Aby w pe³ni wykorzystaæ te pojêcia, 
potrzebne s± dwa rodzaje wyra¿eñ: konstruktory, za pomoc± których specyfikuje siê dany zbiór,
oraz selektory, które okre¶laj± wybran± sk³adow± elementu. Notacja ZRM nie definiowa³a w pe³ni
sk³adni realizuj±cej te dwa typy wyra¿eñ. W dokumentacji notacji pos³ugiwano siê wprawdzie 
wyra¿eniami, aby opisaæ wi±zania elementów z poszczególnymi sk³adowymi (u¿ywaj±c notacji
$\langle p_1 \bind r_1, \dots, p_n \bind r_n \rangle$ ), ale zaznaczono, ¿e tego typu wyra¿eñ 
nie mo¿na stosowaæ w specyfikacjach.

Standard \zet rozwi±zuje ten problem. Od tej pory mo¿na u¿ywaæ wi±zañ dla elementów nazwanych
(wi±zanie to konstrukcja, która ³±czy identyfikator elementu z jego warto¶ci±):

\begin{zed}
\lblot p_1 == r_1, \dots, p_n == r_n \rblot
\end{zed}

oraz selekcji elementów krotki:

\begin{zed}
e.b
\end{zed}

gdzie $e$ odwo³uje siê do nazwy oznaczaj±c± krotkê, a $b$ to dodatnia liczba ca³kowita w zakresie
od $1$ do $n-$krotno¶ci iloczynu kartezjañskiego.

Ilustruje to poni¿sza tabela:

\nowalinia

\begin{tabular}{|c|c|c|c|c|}
\hline
~ & \multicolumn{2}{c}{{\bf ZRM}} \vline & \multicolumn{2}{c}{{\bf Standard \zet}} \vline \\
\cline{2-5}
~ & ~ & ~ & ~ & ~ \\
~ & {\bf Konstruktor} & {\bf Selektor} & {\bf Konstruktor} & {\bf Selektor} \\ 
~ & ~ & ~ & ~ & ~ \\
\hline
~ & ~ & ~ & ~ & ~ \\
{\bf Krotki} & $(x, y, z)$ & & $(x, y, z)$ & $trojka.3$ \\
~ & ~ & ~ & ~ & ~ \\
\hline
~ & ~ & ~ & ~ & ~ \\
{\bf Wi±zania} & & $wiazanie.nazwa$ & $\lblot x == 1, y == 2 \rblot$ & $wiazanie.nazwa$ \\
~ & ~ & ~ & ~ & ~ \\
\hline
\end{tabular}

\nowalinia

\subsection{Schematy w wyra¿eniach}

Wyra¿enie ma warto¶æ okre¶lonego typu. Schemat równie¿ posiada warto¶æ - jest to zbiór 
jego wi±zañ. W dotychczas obowi±zuj±cej notacji ZRM schematy nie mog³y byæ jednak¿e u¿yte 
jako zwyczajne wyra¿enie. ZRM dopuszcza³a wprawdzie u¿ycie schematów w wyra¿eniach rachunku
schematów, ale by³o to ograniczone, poniewa¿ dla schematów obowi±zywa³a oddzielna kategoria
syntaktyczna, jako wyra¿enia schematyczne (ang. {\it schema expressions}). Te rozgraniczenie
pomiêdzy wyra¿eniem, a wyra¿eniem schematycznym stwarza³o ograniczenia w stosowaniu schematów
do zapisywania wyra¿eñ, np. nie mo¿na by³o go u¿yæ jako parametru operatora $\theta$.

Standard \zet ujednolica notacjê likwiduj±c wyra¿enia schematyczne jako oddzieln± kategoriê
syntaktyczn± - mo¿na teraz ich u¿ywaæ jako elementów zwyk³ych wyra¿eñ. Przyk³adowo mo¿liwy
jest nastêpuj±cy zapis:

\begin{schema}{S}
x : \num \\
y : \nat
\end{schema} 

\begin{schema}{\Delta Sx}
S; S'
\where
\theta(S \hide (x)) = \theta(S \hide (x))'
\end{schema}

\subsection{Schematy bez sygnatur}

Schemat bez sygnatury, czyli schemat pusty, mo¿e powstaæ np. w wyniku operacji
ukrywania (opisanej w \ref{r:hiding}). Jest to schemat bez deklaracji, zawieraj±cy
jedynie predykat. Jednak¿e notacja ZRM nie pozwala³a na bezpo¶rednie zapisanie takiego
schematu, co zosta³o zmienione w standardowym \zet. Standard ISO pozwala na deklarowanie
schematów bez czê¶ci deklaracyjnej, np.:

\begin{zed}
Schema \defs [~ | \exists x, y : \num @ x \neq y ~]
\end{zed}

Schemat taki powstaje w wyniku ukrycia $x$ i $y$, jednak taki wynik jest niemo¿liwy do 
zapisania w ZRM:

\begin{zed}
Schema \defs [~ x, y : \num | x \neq y ~] \hide (x, y)
\end{zed}

Schematy puste s± szczególnie u¿yteczne, szczególnie w po³±czeniu z now± w³a¶ciwo¶ci±
standardu \zet sprowadzaj±c± schemat do zwyk³ego wyra¿enia. Schemat pusty u¿yty jako predykat
ma warto¶æ $true$ je¶li jego predykat równie¿ jest $true$ i odpowiednio $false$ gdy predykat
jest $false$. Ujednolica to definicje syntaktyczne notacji i pozwala na bardziej intuicyjne
konstruowanie wyra¿eñ.

\section{Reprezentacja znakowa notacji}

\zet wyra¿one jest w symbolach matematycznych. Jest kilka sposobów ich
kodowania do postaci akceptowalnej przez wspó³czesne systemy komputerowe.
Standard definiuje trzy:

\begin{itemize}
\item{} Unicode
\item{} Znaczniki zgodne z {\LaTeX}
\item{} Znaczniki typu {\it e-mail}
\end{itemize}

Obecnie prowadzone s± te¿ prace nad sposobem reprezentacji \zet w {\bf XML},
nie jest to jednak czê¶æ standardu.

\subsection{Unicode}

Powszechnie zaakceptowany standard Unicode zak³ada wykorzystanie dwóch
bajtów do opisu jednego znaku, zamiast jednego (ASCII). Wiêkszo¶æ znaków
\zet jest ju¿ zdefiniowana w tym standardzie, ale istniej± wyj±tki.
Znaki, których nie ma w obecnej wersji standardu znajduj± siê w AMS/STIX -
zbioru znaków matematycznych proponowanych w nastêpnej wersji Unicode.

\subsection{Znaczniki {\LaTeX}}

Dla potrzeb nadal szeroko stosowanego ASCII i 8-bitowej reprezentacji
znakowej, oraz ze wzglêdu na upowszechnienie siê zapisów \zet w formacie
akceptowanym przez {\LaTeX}, w sk³ad standardu wszed³ zbiór znaczników,
które reprezentuj± elementy notacji. Przyk³adowo: 

\nowalinia
\begin{tabular}{l l c l}
~	& $\Delta$ & ~ & {\tt $\backslash$Delta} \\
~	& $\Xi$ & ~ & {\tt $\backslash$Xi} \\
~	& $\iff$ & ~ & {\tt $\backslash$iff} \\
\end{tabular}

\nowalinia

Identycznie jak w dokumentach {\LaTeX}, standard definiuje sposób
zapisu paragrafów, schematów, aksjomatów i definicji uogólnionych.
Schemat wygl±da wiêc nastêpuj±co:

{\tt
	~\\
	$\backslash$begin\{schema\}\{NAME\} \\
	\dots \\
	$\backslash$where \\
	\dots \\
	$\backslash$end\{schema\}
}

Jêzyk znaczników {\LaTeX} jest obecnie najbardziej rozpowszechnionym
sposobem zapisu dokumentów \zet i najwiêcej narzêdzi potrafi go obs³ugiwaæ.

\subsection{Znaczniki {\it e-mail}}

Ostatni sposób zapisu \zet jest przewidziany jako prosty jêzyk znaczników
przeznaczony do czytania przez cz³owieka. Nie przewiduje siê czytania tego
formatu przez narzêdzia. Znajduje on zastosowanie w korespondencji e-mail,
lub w wy¶wietlaniu specyfikacji przez urz±dzenia o ma³ej rozdzielczo¶ci,
takie jak terminale ASCII.

Podstawow± cech± tego zapisu jest wyodrêbnienie "tekstów specjalnych",
oznaczonych przez znak \%. Np. tekst {\tt \%x} jest w ten sposób odró¿nione
od nazwy {\tt x}. Standard zaleca implementacjê przez urz±dzenie ma³ego zbioru
liter greckich, takich jak {\tt \%Delta\%} ($\Delta$) albo {\tt \%lambda\%}
($\lambda$). Pozosta³e operatory i zapisy w przewa¿aj±cej wiêkszo¶ci mog±
byæ zast±pione przez proste kombinacje znaków ASCII.

Oto przyk³adowy zapis w konwencji e-mail:

{\tt
	~\\
	+== [X] === \\
		\mbox{} \t1 \_ \%u \_ : \%P X \%x \%P X --> \%P X \\
	|-- \\
		\mbox{} \t1 \%A a, b: \%P X @ a \%u b = \{ x : X | x \%e a $\backslash$\slash~ x \%e b \} \\
	-== \\
}

\section{Podsumowanie}

Standard \zet jako miêdzynarodowy standard ISO jest wa¿nym krokiem naprzód w
upowszechnieniu siê notacji jako metody projektowania oprogramowania, oraz
ogólnie szerszego zastosowania metod formalnych. Oprócz wielu wa¿nych
innowacji w celu usuniêcia niejasno¶ci i niejednoznaczno¶ci maj± jednak
miejsce zmiany, które s± niekompatybilne z wcze¶niejszymi wersjami notacji,
a co za tym idzie ze stosowanymi obecnie narzêdziami.

Wydaje siê wiêc, ¿e rola standardu jako czynnika promuj±cego formaln±
specyfikacjê bêdzie siê zwiêkszaæ w miarê powstawania narzêdzi go
obs³uguj±cych. Niestety, obserwuj±c tempo prac i rozwoju nad \zet oraz
zwa¿ywszy na stopieñ skomplikowania tej technologii nie nale¿y oczekiwaæ,
aby powszechne zastosowanie \zet w produkcji oprogramowania by³o kwesti±
najbli¿szych lat. Najprawdopodobniej ograniczy siê ono tymczasem do
projektów o zwiêkszonych wymaganiach co do stabilno¶ci i niezawodno¶ci
systemu.


\chapter{Object-Z}

Object-Z jest rozszerzeniem standardowej notacji \zet, wzbogacaj±cym
j± o elementy programowania zorientowanego obiektowo (OOP).
Paradygmat obiektowy sta³ siê {\it de facto} podstawow± metodologi±
tworzenia oprogramowania od po³owy lat 80-tych, g³ownie dziêki doskona³ej
strukturalizacji kodu, która szczególnie u³atwia rozwijanie i zarz±dzanie
du¿ymi projektami.

Specyfikacja \zet sk³ada siê ze schematów opisuj±cym stany systemu oraz
operacje przej¶æ pomiêdzy nimi. Analiza jednej operacji wymaga analizowania
wszystkich pozosta³ych schematów, co jest niepraktyczne w przypadku
wiêkszych specyfikacji.

Podstawowym pojêciem wprowadzonym Object-Z jest wiêc {\it klasa}. Jest to
fragment specyfikacji, który mo¿e byæ analizowany niezale¿nie od reszty.
Powi±zane ze sob± stany systemu i operacje na nich, enkapsulowane s± w jedn±
grupê, która tworzy klasê. Uproszczenie struktury projektu poprzez te
mechanizmy jest przydatne na ka¿dym etapie tworzenia specyfikacji, pocz±wszy
od budowania schematycznych diagramów, a¿ do sprawdzania i dowodzenia
poprawno¶ci. Klasy mog± wywodziæ siê z innych klas, dziêki dziedziczeniu i
zawieraniu instancji, co umo¿liwia rozbijanie skomplikowanych opisów
obiektów na szereg mniejszych, powi±zanych ze sob± relacjami obiektowymi.

Notacja Object-Z powsta³a w wyniku pracy badawczej Software Verification
Research Centre przy Uniwersytecie w Queensland (Australia). Informacje na
jej temat dostêpne s± w \cite{ObjectZ_91} i \cite{ObjectZ_94}. Oprócz
Object-Z istnieje kilka innych rozszerzeñ obiektowych \zet, jak np. Hall,
ZERO, MooZ, OOZE, Schuman\&Pitt, Z++ i ZEST.

\section{Klasa}

Klasa w Object-Z jest nazwanym schematem, który ma nastêpuj±c± postaæ:

\begin{schema}{Klasa}[Parametry]
	${\it lista dostêpno¶ci}$ \\
	${\it dziedziczone klasy}$ \\
	${\it definicje typów}$ \\
	${\it definicje sta³ych}$ \\
	${\it schematy stanów}$ \\
	${\it stan pocz±tkowy}$ \\
	${\it schematy operacji}$
\where
	${\it niezmiennik historii}$
\end{schema}

Aby opisaæ poszczególne sk³adowe klasy, pos³u¿my siê przyk³adem. Poni¿szy
schemat przedstawia abstrakcyjn± klasê figur, które posiadaj± wspó³rzêdne,
rozmiar, kolor i mog± byæ przesuwane.

\begin{class}{Figure}
\also
\filter (x, y, colour, max\_x, max\_y, bound\_x, bound\_y, \Init, Move) \\
\also
colour : Colour \\
\begin{sidebyside}
\begin{ozaxdef}
max\_x : \num
\ST
max\_x = 1000
\end{ozaxdef}
\nextside
\begin{ozaxdef}
max\_y : \num
\ST
max\_y = 1000
\end{ozaxdef}
\end{sidebyside} \\
\begin{state}
x, y : \real
\ST
x > -max\_x \land x < max\_x \\
y > -max\_y \land y < max\_y
\end{state} \\
\begin{state}
bound\_x, bound\_y : \real
\ST
bound\_x > 0 \land bound\_y > 0 \\
x + bound\_x < max\_x \land y + bound\_y < max\_y
\end{state} \\
\begin{init}
x = y = 0 \\
bound\_x = bound\_y = 0
\end{init} \\
\begin{op}{Move}
\Delta (x,y) \\
dx?, dy? : \num
\ST
x' = x + dx? \\
y' = y + dy?
\end{op}
\end{class}

\subsection{W³a¶ciwo¶ci klasy i lista dostêpno¶ci}

{\it W³a¶ciwo¶ciami klasy} (ang. {\it features}) s± jej atrybuty (sta³e i
zmienne stanów), operacje oraz stan pocz±tkowy. Dla naszej klasy s± nimi:
$x, y, colour, max\_x, max\_y, bound\_x, \\ bound\_y, \Init, Move$.

Definicja klasy rozpoczyna siê od {\it listy dostêpno¶ci}, oznaczonej
operatorem $\filter$. Wszystkie elementy na niej umieszczone s± bezpo¶rednio
dostêpne przez operacje klasy i jej instancje. Je¿eli lista jest pominiêta,
dostêpne s± wszystkie komponenty klasy.

\subsection{Definicje typów i sta³ych}

Wewn±trz klasy mog± znajdowaæ siê definicje typów, aksjomaty oraz definicje
aksjomatyczne.

\begin{zed}
colour : Colour
\end{zed}

\begin{axdef}
max\_x : \num
\where
max\_x = 1000
\end{axdef}

\begin{axdef}
max\_y : \num
\where
max\_y = 1000
\end{axdef}

Definicje te obowi±zuj± wewn±trz klasy. Je¶li znajduj± siê na li¶cie
dostêpno¶ci, to mog± z nich korzystaæ operacje.

Za pomoc± definicji aksjomatycznych zdefiniowali¶my kolor figury, oraz
sta³e $max\_x$, $max\_y$, które okre¶laj± mo¿liwy przedzia³ warto¶ci 
wspó³rzêdnych do $-1000 \upto 1000$.

\subsection{Stany klasy}

Podstawow± ró¿nic± pomiêdzy schematem opisuj±cym stan w Object-Z, a zwyk³ym
\zet jest to, ¿e jest on nienazwany (w standardowym \zet schematy nienazwane
nie s± czê¶ci± jêzyka).

Zmienne, które w schematach stanowych klasy wprowadzane s± czê¶ci
deklaracyjnej, s± zmiennymi, na których operuje klasa. Predykaty tych
schematów s± {\it niezmiennikami klasy}. Niezmienniki s± zawsze spe³nione;
ka¿da operacja musi zagwarantowaæ, ¿e po jej wykonaniu niezmienniki klas
pozostan± prawdziwe. 

Dowolny zestaw danych, który jest zgodny z predykatami stanów klasy, jest
nazywany {\it instancj± klasy}.

W klasie $Figure$ schematy stanów wprowadzaj± zmienne $x, y, bound\_x,
bound\_y$. Ka¿da figura znajduje siê w obszarze prostok±ta ograniczonego
punktami $(x, y)$ oraz $(x + bound\_x, y + bound\_y)$. Zmienne $bound\_x,
bound\_y$ to rozmiar tego prostok±ta, s± one dodatnie.

Niezmiennikiem klasy jest to, ¿e niezale¿nie od operacji wykonywanych na 
figurze, bêdzie siê ona mie¶ciæ wewn±trz zadeklarowanego uk³adu wspó³rzêdnych,
czyli wspó³rzêdne ka¿dego wierzcho³ka opisuj±cego j± prostok±ta znajduj± siê
w przedzia³ach odpowiednio $-max\_x \upto max\_x$ i $-max\_y \upto max\_y$.

\subsection{Stan pocz±tkowy}

W Object-Z schemat, który warunkuje stan pocz±tkowy, zawsze nazywany jest
$\Init$. Jest to pojêcie, które wystêpuje równie¿ w \zet (p.
\ref{r:init_state}), wystêpuj± tu jednak istotne ró¿nice.

Po pierwsze, stan pocz±tkowy jest lokalny dla danej klasy i opisuje tylko
elementy znajduj±ce siê na li¶cie dostêpno¶ci. Niepotrzebna jest wiêc ich
ponowna deklaracja, zatem sygnatura schematu $\Init$ jest pusta.

Po drugie, w Object-Z stan pocz±tkowy nie jest operacj±. Nie zmienia on
warto¶ci zmiennych istniej±cego obiektu, ale jego predykat definiuje warunek.
Warunek ten wraz z niezmiennikami klas definiuj± warunek pocz±tkowy obiektu
(ang. {\it initial condition}). Je¶li dane obiektu spe³niaj± warunek
pocz±tkowy, to znaczy ¿e znajduje siê on w {\it konfiguracji pocz±tkowej}.

W naszym przypadku instancja klasy $Figures$ jest w konfiguracji
pocz±tkowej, je¶li figura znajduje siê na pocz±tku uk³adu wspó³rzêdnych,
oraz d³ugo¶æ i szeroko¶æ opisuj±cego j± prostok±ta s± równe $0$.

\subsection{Operacje}

Operacje w Object-Z s± zdefiniowane podobnie jak w \zet, z t± ró¿nic± (poza
oczywi¶cie zasiêgiem danych, na których s± okre¶lone - wewn±trz klasy) ¿e
zamiast odwo³ania do istniej±cego schematu, wystêpuje w ich sygnaturze 
$\Delta$-lista. Ma ona postaæ  $\Delta(v_1, \dots, v_n)$, gdzie 
$v_1, \dots, v_n$ to s± zmienne, których warto¶æ bêdzie zmieniona w wyniku
operacji.

Inaczej ni¿ w \zet, o ile operacja nie zmienia warto¶ci zmiennych, nie ma 
potrzeby jawnego deklarowania ich w sygnaturze (nie ma wiêc odpowiednika
zapisu $\Xi S$), ani pisania predykatu postaci $x' = x$.

Operacja mo¿e mieæ warunki wstêpne, w postaci predykatów okre¶lonych na
niedekorowanych zmiennych. Jest mo¿liwe, ¿e dla poprawnej instancji klasy
(dane spe³niaj± niezmienniki klasy) nie bêdzie mo¿liwe zastosowanie danej
operacji, gdy¿ nie bêd± spe³nione jej warunki wstêpne.

W klasie $Figures$ wystêpuje jedna operacja $Move$, która `przesuwa' obiekt
w oparciu o podane parametry $dx?, dy?$, zmieniaj±c w ten sposób zmienne
$x, y$. Nie ma potrzeby podawania dodatkowych warunków na $dx?, dy?$,
gdy¿ operacja i tak bêdzie poprawna tylko wtedy, gdy zostan± zachowane
niezmienniki klasy.

\section{Instancje}

Tworzenie instancji jest podstawow± technik± ³±czenia klas. Typowy
system sk³ada siê z wielu klas i ich instancji, Object-Z umo¿liwia nie tylko
opisanie jak siê zachowuj± indywidualne obiekty, ale równie¿ interakcje
zachodz±ce pomiêdzy nimi.

Podstawowym zapisem instancji obiektu jest:

\begin{zed}
	f : Figure
\end{zed}

$f$ jest referencj± do instancji klasy $Figure$. Nale¿y zauwa¿yæ, ¿e jest to
tylko referencja, nie mówi ona nic o stanie danego obiektu. Jego stan mo¿e
siê zmieniaæ, ale $f$ pozostaje niezmienne.

Dwie referencje mo¿na porównaæ ze sob±, aby ustaliæ, czy mamy do czynienia z
tym samym obiektem. Zapis:

\begin{zed}
	f1, f2 : Figure
\end{zed}

nie musi oznaczaæ deklaracji dwóch ró¿nych instancji $Figure$. Wymusiæ to
mo¿na dodatkowym predykatem $f1 \neq f2$.

Jak ju¿ by³o wspomniane, instancja obiektu oznacza zestaw danych zgodny z
niezmiennikami klasy. Niepotrzebne s± wiêc dodatkowe predykaty na $f$,
poniewa¿ referencja ta odnosi siê do prawid³owej instancji, spe³niaj±cej
niezmienniki klasy $Figure$.

Do komponentów klasy (znajduj±cych siê na li¶cie dostêpno¶ci) mo¿na
odwo³ywaæ siê za pomoc± typowej notacji z kropk±. Przyk³adowo

\begin{zed}
	f.x
\end{zed}

jest odwo³aniem siê do zmiennej $x$ klasy $Figure$, natomiast

\begin{zed}
	f.Move
\end{zed}

jest odniesieniem siê do operacji $Move$.

Do zilustrowania tych pojêæ pos³u¿ymy siê przyk³adem klasy, zawieraj±cej
dwie figury.

\begin{class}{FigurePair}
\also
\filter (\Init, MoveBoth, SameBoundingBox) \\
\also
\begin{state}
f1, f1 : Figure
\ST
f1 \neq f2
\end{state} \\
\begin{init}
f1.\Init \\
f2.\Init
\end{init} \\
\also \also
MoveBoth \defs f1.Move \land f2.Move \\
\begin{op}{SameBoundingBox}
\ST
f1.bound\_x = f2.bound\_x \\
f1.bound\_y = f2.bound\_y \\
\end{op}
\end{class}

W klasie tej, która zawiera dwie instancje klasy $Figure$ definiujemy
najpierw schemat stanu, który mówi, ¿e referencje $f1, f2$ maj± odnosiæ siê
do dwóch ró¿nych obiektów (co nie znaczy ¿e obiekty te nie mog± byæ takie
same, np. identyczne figury po³o¿one w tym samym miejscu na uk³adzie
wspó³rzêdnych).

Stan pocz±tkowy $\Init$ okre¶la, ¿e obiekt $FigurePair$ jest w konfiguracji
pocz±tkowej, je¶li równie¿ s± w niej instancje $f1, f2$. Mo¿emy zapisaæ
$f1.\Init$, gdy¿ $\Init$ wystêpuje na li¶cie dostêpno¶ci klasy $Figure$.

Operacja $MoveBoth$ jest zadeklarowana jako koniunkcja operacji $Move$ obu
figur ($f1$ i $f2$). Jest to koniunkcja schematów, opisana ju¿ w
rozdziale o rachunku schematów (\ref{r:schema_calculus}).

$SameBoundingBox$ nie zmienia nic w ¿adnym obiekcie, nie ma potrzeby
zatem deklarowania $\Delta$-listy. Operacja bêdzie wykonana pomy¶lnie,
je¿eli figury $f1, f2$ bêd± mia³y ten sam rozmiar (prostok±ta opisuj±cego).

W Object-Z okre¶lone s± standardowe operatory \zet ³±cz±ce operacje,
jak np. z³o¿enie ($~\semi~$) czy potok ($~\pipe~$), a oprócz tego dwa
dodatkowe: operator równoleg³y ($a.Op1 \parallel b.Op2$) i zasiêgu 
($Op1 @ Op2$). Wiêcej informacji na ten temat w \cite{ObjectZ_91}.

\section{Dziedziczenie}

Dziedziczenie jest drug± technik± ³±czenia klas. Za jego pomoc± mo¿na
definiowaæ skomplikowane klasy poprzez w³±czanie w³a¶ciwo¶ci prostszych
klas, bardziej z³o¿one struktury tworzymy wiêc w sposób przyrostowy.

W klasie pochodnej, wszystkie definicje sta³ych i typów s± ³±czone z
definicjami z klasy nadrzêdnej. Podobnie s± ³±czone schematy - te pochodz±ce
z klasy nadrzêdnej i te zadeklarowane w klasie pochodnej. W wypadku kolizji
nazw, schematy s± spajane w jeden (za pomoc± koniunkcji schematów), tak samo 
niezmienniki historii. Dotyczy to równie¿ nienazwanych schematów stanu.

Aby zadeklarowaæ klasê nadrzêdn±, wystarczy w³±czyæ jej nazwê do czê¶ci
deklaracyjnej.

\begin{class}{ShadowedFigure}
\also
\filter (x, y, colour, max\_x, max\_y, bound\_x, bound\_y, \\
shadow\_x, shadow\_y, \Init, Move) \\
\also
Figure\\
\begin{state}
shadow\_x, shadow\_y : \real
\ST
\end{state} \\
\begin{init}
shadow\_x = x + 2 \\
shadow\_y = y + 2 \\
\end{init} \\
\begin{op}{Move}
\Delta (shadow\_x,shadow\_y) \\
dx?, dy? : \num
\ST
shadow\_x' = shadow\_x + dx? \\
shadow\_y' = shadow\_y + dy?
\end{op}
\end{class}

Taka klasa jest równowa¿na nastêpuj±cej wersji rozszerzonej:

\begin{class}{ShadowedFigure}
\also
\filter (x, y, colour, max\_x, max\_y, bound\_x, bound\_y, \\
shadow\_x, shadow\_y, \Init, Move) \\
\also
colour : Colour \\
\begin{sidebyside}
\begin{ozaxdef}
max\_x : \num
\ST
max\_x = 1000
\end{ozaxdef}
\nextside
\begin{ozaxdef}
max\_y : \num
\ST
max\_y = 1000
\end{ozaxdef}
\end{sidebyside} \\
\begin{state}
x, y : \real \\
bound\_x, bound\_y : \real \\
shadow\_x, shadow\_y : \real \\
\ST
x > -max\_x \land x < max\_x \\
y > -max\_y \land y < max\_y \\
bound\_x > 0 \land bound\_y > 0 \\
x + bound\_x < max\_x \land y + bound\_y < max\_y \\
shadow\_x > x \land shadow\_y > y
\end{state} \\
\begin{init}
x = y = 0 \\
bound\_x = bound\_y = 0 \\
shadow\_x = x + 2 \\
shadow\_y = y + 2
\end{init} \\
\begin{op}{Move}
\Delta (x,y,shadow\_x,shadow\_y) \\
dx?, dy? : \num
\ST
x' = x + dx? \\
y' = y + dy? \\
shadow\_x' = shadow\_x + dx? \\
shadow\_y' = shadow\_y + dy?
\end{op}
\end{class}

Object-Z daje mo¿liwo¶æ redefiniowania operacji w klasie pochodnej (z
wy³±czeniem mechanizmu ³±czenia schematów), lub nawet usuniêcia jej. Do tego
s³u¿± s³owa kluczowe $\redef$ i $\remov$. Przyk³adowo, definicja klasy
nie zawieraj±cej operacji $Move$:

\begin{class}{ImmovableFigure}
\also
Figure[\remov~Move~]
\end{class}

Deklaracja klas figur przesuwalnych tylko poziomo:

\begin{class}{FigureMovedInX}
\also
Figure[\redef~Move~] \\
\begin{op}{Move}
\Delta (x) \\
dx? : \num
\ST
x' = x + dx? \\
\end{op}
\end{class}



\section{Polimorfizm}

Poliformizm jest to mechanizm, który pozwala na zadeklarowanie zmiennej,
której warto¶æ mo¿e byæ obiektem jednej z wielu mo¿liwych klas. W
programowaniu zorientowanym obiektowo u¿yteczne jest za³o¿enie, ¿e zmienna
mo¿e byæ instancj± danej klasy, lub dowolnej pochodnej tej klasy
(dziedzicz±cej po niej).

W Object-Z, je¶li $C$ jest klas±, to notacja

\begin{zed}
	c_1 : C
\end{zed}

oznacza obiekt klasy $C$, w odró¿nieniu od

\begin{zed}
	c_2 : \poly C
\end{zed}

gdzie $c_2$ mo¿e byæ instancj± $C$ lub dowolnej klasy pochodnej.

Odwo³anie siê do operacji $c_2.Op$ mo¿e, ale nie musi, oznaczaæ odwo³anie
siê do operacji $Op$ zdefiniowanej w klasie, której typu jest instancja.
Je¿eli definicja $Op$ znajduje siê w której¶ z klas nadrzêdnych, a nie w
klasie danej instancji, to oczywi¶cie $c_2.Op$ nawi±zuje do tej definicji.
Dziêki mechanizmowi dziedziczenia klasy mog± redefiniowaæ operacjê,
dostarczaj±c ich specjalizowane wersje.

\section{Historia obiektu}

Stan obiektu mo¿e siê zmieniaæ, poprzez wykonywanie na nim operacji. Jak
wiemy, obiekt rozpoczyna swoj± egzystencjê od stanu pocz±tkowego, zgodnego z
warunkiem $\Init$. Potem mog± byæ na nim wykonywane operacje.

Powi±zanie stanów obiektu $st_i$ z operacjami $op_i$ jest przedstawione
nastêpuj±co:

$$
st_1 \stackrel{op_1}{\longrightarrow} 
st_2 \stackrel{op_2}{\longrightarrow} 
\dots
st_{n-1} \stackrel{op_{n-1}}{\longrightarrow} st_n
$$

Lista par $st_i, op_i$ tworzy historiê operacji obiektu. W opisie klasy
mog± zawieraæ siê {\it niezmienniki historii}. W Object-Z dodano 
operatory wywodz±ce siê z logiki temporalnej, przydatnej do ich opisu.

\nowalinia
\begin{tabular}{l l}
$\t1 \always P \t1$ & $P$ jest spe³nione na ka¿dym etapie w historii \\
$\t1 \eventually P$ & jest mo¿liwe, ¿e istnieje etap, w którym zachodzi $P$ \\
$\t1 \atnext P$ & $P$ jest spe³nione na nastêpnym etapie \\
\end{tabular}
\nowalinia

Oprócz tego

\nowalinia
\begin{tabular}{l l}
$\t1 {\bf op} \t1$ & Nazwa ostatniej operacji, która wyst±pi³a na obiekcie
\end{tabular}
\nowalinia

Przyk³adem zastosowania tych operatorów, mo¿e byæ zadeklarowanie klasy
figur, które s± przesuwalne tylko w prawo.

\begin{class}{FigureMovedRight}
\also
Figure
\ST
\always ({\bf op} = Move \implies ((\atnext x) > x))
\end{class}

\chapter{System STOCKPACK - przyk³adowa specyfikacja}

\section{Za³o¿enia systemu}

Celem systemu STOCKPACK jest zapewnienie u¿ytkownikom urz±dzeñ przeno¶nych
PDA platformy do obserwacji i monitorowania danych gie³dowych, narzêdzi analizy
technicznej, oraz symulacji portfela inwestycyjnego. U¿ytkownicy s± w stanie 
pobieraæ dane gie³dowe z Internetu i wy¶wietlaæ wykresy spó³ek wraz z naniesionymi
typowymi wska¼nikami (takimi jak RSI, MACD). Oprócz tego aplikacja zawiera implementacjê
portfela, w którym dla poszczególnych spó³ek u¿ytkownicy mog± zapisywaæ przeprowadzone
transakcje w ró¿nych walutach. 

STOCKPACK jest rzeczywistym systemem, zaimplementowanym na platformie PalmOS. W jego
sk³ad wchodzi g³ówny program przeznaczony do uruchomienia na urz±dzeniu PDA, oraz
programy pomocnicze, realizuj±ce synchronizacjê danych z ró¿nych ¼róde³ (Internet, pliki
z danymi gie³dowymi w formacie Metastock na komputerze desktop). 

Przedmiotem niniejszego rozdzia³u jest g³ówny modu³ systemu, czyli aplikacja systemu 
operacyjnego Palm OS. Jej rzeczywist± implementacjê tworzy 20.000 linii kodu w jêzyku 
programowania C. 

Autorami oprogramowania s± Maciej Mochol i Jaros³aw Nowisz. System jest dostêpny
komercyjnie, dystrybutorem jest firma Aeronic (\cite{Aeronic}).

\section{Specyfika programowania aplikacji mobilnych w systemie Palm OS}

Zastosowanie notacji \zet do opisu aplikacji mobilnej ma szereg zalet, g³ównie ze wzglêdu
wymagañ, jakie stawia ¶rodowisko systemowe wobec programisty. Spotyka siê on bowiem z 
wieloma trudno¶ciami, które wymagaj± odpowiedniej metodologii ju¿ na etapie projektu.
W przeciwieñstwie bowiem do wielu systemów, które usprawniaj± tworzenie, szczególnie
bazodanowych aplikacji, niejednokrotnie dostarczaj±c w³asnej metodologii projektowania
odpowiedniej dla zastosowania, tworzenie aplikacji dla Palm OS opiera siê na bardzo
dok³adnym i szczegó³owym programowaniu.

Do najwa¿niejszych trudno¶ci nale¿±:

\begin{itemize}

\item{} jêzyk C nie jest intuicyjny i mo¿e wydawaæ siê niejednoznaczny, wiele jego konstrukcji 
stwarza niebezpieczeñstwo b³êdnej interpretacji przez programistê i pope³nienia b³êdu,

\item{} system Palm OS wprowadza wprawdzie pewne mechanizmy bezpieczeñstwa i ochrony danych,
jest to jednak mechanizm nieporównywalny ze wspó³czesnymi systemami operacyjnymi. W szczególno¶ci
mo¿liwe jest nadpisanie danych, pamiêci i kodu innych aplikacji, poprzez b³êdne operacje
na wska¼nikach,

\item{} biblioteka funkcji standardowych dostêpnych programi¶cie nie jest zgodna ze standardem C.
Wiele u³atwieñ przyjêtych jako standard nie jest zaimplementowanych. Czêsto brak typowych 
funkcji znanych z systemów stacjonarnych (np. atoi() ),

\item{} urz±dzenie PDA posiada zazwyczaj niewielkie zasoby pamiêci operacyjnej, oraz ma³± moc 
procesora. S± sytuacje, gdy brak dba³o¶ci podczas projektowania i programowania, które 
w systemach stacjonarnych co najwy¿ej doprowadzi³yby do niepotrzebnego zu¿ycia zasobów, 
na palmtopie zazwyczaj uniemo¿liwia poprawne funkcjonowanie aplikacji. Czêsto wrêcz
niemo¿liwe jest dokoñczenie projektu, bez uprzedniej weryfikacji za³o¿eñ i wprowadzenia
niezbêdnych poprawek do stworzonego ju¿ kodu,

\item{} brak implementacji relacyjnej bazy danych, a nawet systemu plików powoduje, ¿e programista 
pracuje na poziomie obszarów pamiêci i wska¼ników, co znacznie zwiêksza ryzyko pomy³ki
i rozbie¿no¶ci implementacji z za³o¿eniami projektowymi. 

\end{itemize}

Dobrym rozwi±zaniem jest wiêc wprowadzenie metod formalnych do fazy projektowej. Oprócz samych korzy¶ci p³yn±cych ze strukturalizacji projektu, notacja \zet dostarcza wiele narzêdzi pomocnych
przy weryfikacji specyfikacji, zmniejszaj±c ryzyko pomy³ki projektanta lub programisty.

\section{Specyfikacja}

Niniejsza specyfikacja powsta³a przy u¿yciu narzêdzia Z/EVES, opisanego ju¿ w tej pracy. Ze wzglêdu na charakter aplikacji, g³ównym celem autora by³o zapewnienie spójno¶ci danych po wykonaniu ró¿nych operacji. Wiele b³êdów, które mo¿e pope³niæ programista wynika z jego pomy³ek, a nie na skutek nieprawid³owej interpretacji za³o¿eñ projektowych, jednak w przypadku aplikacji mobilnej bez formalnego podej¶cia do fazy projektowej bardzo prawdopodobne s± b³êdy projektanta. Jednym z newralgicznych punktów systemu jest obs³uga bazy danych. W wyniku braku na urz±dzeniach mobilnych standardu relacyjnego dostêpu do danych, trudno jest zagwarantowaæ poprawno¶æ wykonywanych operacji, gdy¿ ca³a praca potrzebna do utrzymania za³o¿onej struktury danych musi zostaæ wykonana po stronie aplikacji. 

Notacja \zet jest dobrym narzêdziem do modelowania relacji pomiêdzy poszczególnymi tabelami. Pojêcia znane z teorii mnogo¶ci, rachunek zbiorów i relacji oraz operatory \zet pozwalaj± w ³atwy sposób modelowaæ relacje 1-1, 1-n, itd., znane ze ¶wiata baz danych.

W specyfikacji systemu StockPack g³ówny nacisk po³o¿ono na za³o¿enie, ¿e wszystkie operacje na danych w systemie nie zmieniaj± z góry za³o¿onej struktury danych. Z tego powodu skoncentrowano siê na weryfikowaniu i dowodzeniu poprawno¶ci tych faktów. System Z/EVES, poprzez maszynê dowodzenia, dostarcza narzêdzi do weryfikacji relacji g³ównie poprzez mechanizm sprawdzania dziedzin {\it (ang. domain check)}. Sprawdzenie dziedziny jest dokonywane podczas weryfikacji paragrafu specyfikacji, w tym celu jest tworzony specjalny teoremat, np. {\it $SESSIONREC\$domainCheck$}, który zawiera wszystkie predykaty niezbêdne dla poprawno¶ci definicji paragrafu i wynikaj±ce z zadeklarowanych struktur. Przyk³adem takiego automatycznie generowanego predykatu jest zadeklarowanie wywo³ania funkcji:

\begin{zed}
y = funkcja ~ x
\end{zed}

Aby ten zapis by³ prawid³owy, musi byæ spe³niony warunek $x \in \dom funkcja$. Predykat ten jest automatycznie dodawany do teorematu sprawdzaj±cego poprawno¶æ dziedzin.

Dziêki takiej konstrukcji weryfikacja i dowodzenie poprawno¶ci odbywa siê niejako automatycznie, uwalniaj±c u¿ytkownika od ¿mudnego dowodzenia za³o¿eñ projektowych poprzez testowe teorematy, co w przypadku wiêkszych specyfikacji jest bardzo skomplikowane. 

\subsection{Deklaracje struktur danych}

Potrzebna jest deklaracja ³añcucha znaków, u¿ywanego do przechowywania nazw, identyfikatorów i innych danych. £añcuch znaków jest sekwencj± liczb naturalnych. Niepotrzebne jest dla celów tej specyfikacji komplikowanie tej definicji poprzez wprowadzanie dodatkowych za³o¿eñ.

\begin{zed} 
CHARS == \seq \nat  
\end{zed} 

Drugim podstawowym typem danych s± liczby zmiennoprzecinkowe typu FLOAT, które s³u¿± do przechowywania danych nt. cen spó³ek i warto¶ci transakcji. Poniewa¿ notacja \zet nie zawiera definicji liczb rzeczywistych, mo¿emy przyj±æ dla uproszczenia, ¿e typ $FLOAT$ to po prostu liczby ca³kowite (maj± podobne w³a¶ciwo¶ci).

\begin{zed} 
FLOAT == \num  
\end{zed} 

Analogiczna definicja daty:

\begin{zed} 
DATE == \nat  
\end{zed} 

i czasu:

\begin{zed} 
TIME == \nat  
\end{zed} 

W wielu przypadkach potrzebny jest aktualny czas i data, np. do zaksiêgowania transakcji. Wprowadzamy zatem dwie warto¶ci, $today$ i $now$, przyjmujemy, ¿e zawieraj± one aktualn± datê i czas. 

\begin{axdef} 
  today: DATE 
\end{axdef} 

\begin{axdef} 
  now: TIME 
\end{axdef} 

Notowania spó³ek mog± pochodziæ z ró¿nych ¼róde³ (np. z ró¿nych gie³d lub rynków kapita³owych). Zbiór $SOURCE$ jest zbiorem mo¿liwych ¼róde³ notowañ spó³ek.

\begin{zed} 
[SOURCE] 
\end{zed} 

Oprócz tego potrzebne nam jest domy¶lne ¼ród³o. W dalszej czê¶ci nie wykorzystujemy faktu, ¿e notowania mog± pochodziæ z ró¿nych miejsc, mo¿na to rozbudowaæ w miarê potrzeb pó¼niej. Jest to przyk³ad niedeterminizmu \zet.

\begin{axdef} 
  default\_source: SOURCE 
\end{axdef} 

Sesja jest pojêciem rynku kapita³owego, które oznacza dzieñ, w którym dokonuje siê transakcji, ustalaj±c w ten sposób ceny spó³ek. Zazwyczaj posiada numer identyfikacyjny. W tej specyfikacji jest zamodelowana przy u¿yciu schematu, który zawiera datê sesji i jej numer. W dalszej czê¶ci bêdzie wykorzystywana instancja $SESSIONREC$, która jest zbiorem wi±zañ identyfikatorów $session\_number$ i $session\_date$ z ich warto¶ciami (czyli $\theta SESSIONREC$). Wykorzystywanie zapisu $\theta$ nie jest dozwolone w ZRM, ale Z/EVES pozwala na stosowanie specjalnej notacji, która pozwala przypisaæ zbiór wi±zañ do instancji schematu. Dziêki takiemu rozwi±zaniu mo¿liwe jest wygodne strukturalizowanie danych, poprzez stosowanie podej¶cia podobnego do projektowania obiektowego.

\begin{schema}{SESSIONREC }  session\_date: DATE \\ 
  session\_number: \nat  
\end{schema} 

Schemat $SESSIONS$ jest w zasadzie zbiorem poszczególnych sesji. Mo¿na by go zdefiniowaæ jako alias typu, ale ze wzglêdów strukturalnych wygodniej przedstawiæ g³ówne definicje danych w postaci schematów (które zawieraj± informacje o stanach). 

\begin{zed}
SESSIONS \defs [~ sessions: \power SESSIONREC ~] 
\end{zed}

Podobnie definiujemy pojêcie waluty, w sk³ad której wchodzi jej cena w stosunku do dolara oraz skrót w standardzie ISO.

\begin{schema}{CURRENCY }  iso\_code: CHARS \\ 
  usd\_ratio: FLOAT 
\end{schema} 

Poniewa¿ przechowujemy ceny walut relatywnie w stosunku do dolara, definiujemy specjaln± instancjê waluty, oznaczaj±cej dolar amerykañski.

\begin{axdef} 
  usd\_currency: CURRENCY 
\end{axdef} 

£±czymy wprowadzone pojêcia walut w schemat, wprowadzaj±c predykaty jako niezmienniki. Predykaty te mówi±, ¿e zbiór walut przechowywanych przechowywanych systemie nigdy nie jest pusty i zawsze zawiera definicjê dolara. Oprócz tego nie mog± siê powtarzaæ elementy z identycznym kodem ISO ? to znaczy gwarantujemy, ¿e kod ISO jest w systemie jednoznaczny i unikalny.
 
\begin{schema}{CURRENCYDATA }  currencies: \power CURRENCY \\ 
\where \\ 
  currencies \neq \emptyset \\ 
  usd\_currency \in currencies \\ 
  \forall x, y: currencies @ x.iso\_code = y.iso\_code \implies x = y 
\end{schema} 

Analogicznie definiujemy pojêcie spó³ki. Jest to rekord, który zawiera informacjê o walucie, ¼ródle pochodzenia notowañ oraz czas i datê ostatniej modyfikacji.

\begin{schema}{STOCKREC }  name, symbol: CHARS \\ 
  currency: CURRENCY \\ 
  source\_id: SOURCE \\ 
  mod\_date: DATE \\ 
  mod\_time: TIME 
\end{schema} 

Schemat $STOCKS$ kumuluje dane o wszystkich spó³kach w systemie oraz o walutach (poprzez w³±czenie schematu $CURRENCYDATA$). Jego niezmiennikiem jest predykat, który gwarantuje, ¿e wszystkie kody walut zawarte w rekordach spó³ki musz± znajdowaæ siê równie¿ w zmiennej $currencies$ schematu $CURRENCYDATA$.

\begin{schema}{STOCKS }  CURRENCYDATA \\ 
  stock\_ids: \power STOCKREC \\ 
\where \\ 
  \forall x: STOCKREC @ x \in stock\_ids \implies x.currency \in currencies 
\end{schema} 
Typ $VALTYPE$ okre¶la mo¿liwe typy warto¶ci notowania spó³ki. System STOCKPACK definiuje ceny otwarcia, zamkniêcia, maksymaln±, minimaln± oraz obrót.

\begin{zed} 
VALTYPE ::= OPEN | CLOSE | MAX | MIN | VOL 
\end{zed} 

Notowania mog± byæ dwojakiego typu: dzienne lub ci±g³e (intraday). Notowania dzienne podawane s± pod koniec sesji i obliczane s± na podstawie jej przebiegu. Notowania zmienne stanowi± zapis przebiegu sesji.

\begin{zed} 
STOCKTYPE ::= DAILY | INTRADAY 
\end{zed} 

Typ $VALUES$ definiuje jeden punkt warto¶ci. Zdefiniowany jako ca³kowita funkcja, ka¿demu typowi warto¶ci przyporz±dkowuje jedn± warto¶æ zmiennoprzecinkow±. Razem zbiór definiuje jeden chwilowy stan warto¶ci spó³ki.

\begin{zed} 
VALUES == VALTYPE \fun FLOAT 
\end{zed} 

Typ $STOCKDAILYPOINTS$ wi±¿e dane sesji z notowaniami. Niektórym sesjom (funkcja czê¶ciowa) przyporz±dkowane s± warto¶ci {\it daily}. Oznacza to, ¿e w systemie nie dla ka¿dej sesji musi byæ zdefiniowana jej warto¶æ (mo¿e byæ nieznana albo nie istnieæ).

\begin{zed} 
STOCKDAILYPOINTS == SESSIONREC \pfun VALUES 
\end{zed} 

Definicja zbioru notowañ ci±g³ych $STOCKINTRAPOINTS$ jest podobna do poprzedniej, z tym, ¿e jednej sesji przyporz±dkowuje siê zbiór par zawieraj±cych czas notowania i warto¶æ. W ten sposób dla jednej sesji mo¿e byæ wiele notowañ chwilowych (czyli relacja $1 \mapsto N$ znana z relacyjnych baz danych).

\begin{zed} 
STOCKINTRAPOINTS == SESSIONREC \pfun TIME \cross VALUES 
\end{zed} 

Zdefiniowane struktury, podobnie jak waluty i spó³ki zamykamy w jeden schemat $STOCKDATA$. Ka¿dy stan tego schematu zawiera informacje o walutach, spó³kach i ich warto¶ciach warto¶ciach systemie. Definiujemy przy tym niezmienniki zapewniaj±ce spójno¶æ danych ? dwa pierwsze predykaty mówi± o tym, ¿e wszystkie identyfikatory spó³ek zawarte w typach $STOCKDAILYPOINTS$ i $STOCKINTRAPOINTS$ s± spójne z danymi schematu $STOCK$ (czyli przechowywan± tabel± spó³ek). Nastêpne dwa predykaty ³±cz± tabelê sesji ze zbiorami punktów ? niemo¿liwa w ten sposób jest sytuacja, ¿e w zbiorach punktów notowañ jest zawarta informacja o jakiej¶ sesji, o której nie ma informacji w g³ównej tabeli.

\begin{schema}{STOCKDATA }  STOCKS \\ 
  SESSIONS \\ 
  daily\_data: STOCKREC \pfun STOCKDAILYPOINTS \\ 
  intra\_data: STOCKREC \pfun STOCKINTRAPOINTS \\ 
\where \\ 
  \dom daily\_data \subseteq stock\_ids \\ 
  \dom intra\_data \subseteq stock\_ids \\ 
  \forall x: \ran daily\_data @ \dom x \subseteq sessions \\ 
  \forall x: \ran intra\_data @ \dom x \subseteq sessions 
\end{schema} 
Alarm s³u¿y do zawiadomienia u¿ytkownika o sytuacji, w której warto¶æ jakiego¶ waloru przekracza pewien okre¶lony próg. Mo¿e to byæ sygna³ sprzeda¿y lub kupna akcji. 

$ALARMTYPE$ definiuje 5 rodzajów progów: alarm nast±pi wtedy, gdy warto¶æ jest wiêksza, wiêksza lub równa, równa, mniejsza, mniejsza lub równa od warto¶ci progowej.

\begin{zed} 
ALARMTYPE ::= MORE | MOREEQ | EQ | LESS | LESSEQ 
\end{zed} 

Schemat $ALARMREC$ zawiera warto¶æ progow±, rodzaj progu, oraz warto¶ci waloru s³u¿±ce do okre¶lenia stanu alarmu.

\begin{schema}{ALARMREC }  trigger\_val: ALARMTYPE \cross 
VALTYPE \cross FLOAT 
\end{schema} 

Schemat $ALARMDATA$ ³±czy zbiór alarmów i dane o spó³kach. Predykat gwarantuje, ¿e nie istniej± alarmy dla nieokre¶lonych spó³ek.

\begin{schema}{ALARMDATA }  STOCKS \\ 
  alarms: STOCKREC \pfun \power ALARMREC \\ 
\where \\ 
  \dom alarms \subseteq stock\_ids 
\end{schema} 

Transakcja jest podstawowym pojêciem, u¿ywanym do zbudowania pojêcia portfela. Za³o¿eniem funkcjonalnym programu jest, aby u¿ytkownik mia³ mo¿liwo¶æ archiwizowania swoich transakcji, z których mo¿e potem obliczaæ ró¿ne dane statystyczne (takie jak np. ilo¶æ zgromadzonego kapita³u).

Transakcja mo¿e byæ dwojakiego typu, kupna lub sprzeda¿y.

\begin{zed} 
TRANSTYPE ::= BUY | SELL 
\end{zed} 

Schemat $TRANSACTIONREC$ opisuje jedn± transakcjê. W jej sk³ad wchodz± informacje o cenie zakupu lub sprzeda¿y, prowizja od transakcji, zysk i ilo¶æ akcji w transakcji. Transakcja przechowuje te¿ dane czasie jej zawarcia.

\begin{schema}{TRANSACTIONREC }  trans\_date: DATE \\ 
  trans\_price, trans\_fee, profit, buy\_price: FLOAT \\ 
  trans\_amount: \nat  \\ 
  mod\_date: DATE \\ 
  mod\_time: TIME 
\end{schema} 

Schemat $TRANSDATA$ wi±¿e wszystkie transakcje w systemie ze spó³kami. Eliminuje istnienie transakcji dla nieokre¶lonych spó³ek.

\begin{schema}{TRANSDATA }  STOCKS \\ 
  transactions: STOCKREC \pfun \power (TRANSTYPE \cross TRANSACTIONREC) \\ 
\where \\ 
  \dom transactions \subseteq stock\_ids 
\end{schema} 

Na koñcu wprowadzamy pojêcie portfolio, które zawiera wszystkie jak dot±d zdefiniowane struktury. W obrêbie jednego portfolio s± informacje o walutach, spó³kach, notowaniach, alarmach i transakcjach.

Schemat $PORTFOLIOREC$ zawiera informacje specyficzne dla jednego portfolio, w tym przypadku jego nazwê, któr± przypisuje mu u¿ytkownik. STOCKPACK obs³uguje wiele portfolii, ale ze wzglêdu na rozmiar pracy nie s± celowe dalsze definicje. W obrêbie jednego portfolio mo¿na opisaæ ca³± funkcjonalno¶æ systemu.

\begin{schema}{PORTFOLIOREC }  portfolio\_name: CHARS 
\end{schema} 

Schemat $PORTFOLIO$ ³±czy wszystkie rodzaje danych systemu STOCKPACK.
Na nim okre¶lone s± operacje w systemie.

\begin{zed}
PORTFOLIO \defs PORTFOLIOREC \land STOCKDATA \\
\t5	\land ALARMDATA \land TRANSDATA 
\end{zed}

\subsection{Stan pocz±tkowy}

W podrozdziale tym zdefiniowany jest stan pocz±tkowy systemu. 

Zbiór walut pocz±tkowo zawiera tylko informacje o dolarze.

\begin{zed}
CurrenciesInit \defs [~ CURRENCYDATA' | currencies' = \{usd\_currency\} ~] 
\end{zed}

Zbiory spó³ek, sesji i punktów s± puste.

\begin{zed}
StockDataInit \defs \\
\t1	[~ STOCKDATA' | \\ 
\t2	stock\_ids' = \emptyset \land sessions' = \emptyset \land \\
\t2	daily\_data' = \emptyset \land intra\_data' = \emptyset ~] 
\end{zed}

Zbiór alarmów jest pusty.

\begin{zed}
AlarmDataInit \defs [~ ALARMDATA' | alarms' = \emptyset ~] 
\end{zed}

W systemie nie istniej± ¿adne transakcje.

\begin{zed}
TransDataInit \defs [~ TRANSDATA' | transactions' = \emptyset ~] 
\end{zed}

Nazwa portfolio jest ci±giem pustym.

\begin{zed}
PortfolioRecInit \defs [~ PORTFOLIOREC' | portfolio\_name' = 
\langle \rangle  ~] 
\end{zed}

Za pomoc± koniunkcji schematów definiujemy ca³kowit± operacjê $Init$ na schemacie $PORTFOLIO$.

\begin{zed}
PortfolioInit \defs \\
\t1  CurrenciesInit \\ 
\t1  \land StockDataInit \\
\t1  \land AlarmDataInit \\
\t1  \land TransDataInit \\
\t1  \land PortfolioRecInit 
\end{zed}

Poni¿szy teoremat dowodzi, ¿e tak okre¶lony stan pocz±tkowy nie jest sprzeczny z ¿adnym niezmiennikiem w systemie, to znaczy ¿e istnieje taki zbiór wi±zañ $\theta PORTFOLIO$ dla którego mo¿liwy jest taki stan pocz±tkowy.

\begin{theorem}{PortfolioInitPossible}
        \exists PORTFOLIO' @ PortfolioInit
\end{theorem}

Aby dowie¶æ poprawno¶ci tego teorematu, wystarczy skorzystaæ z automatycznego
Dowodzenia przy u¿yciu redukcji.
                                                                                                                             
\begin{zproof}
        prove by reduce
\end{zproof}

\subsection{Operacje na walutach}

Podrozdzia³ ten okre¶la mo¿liwe operacje na danych o walutach w systemie.

Pierwsz± operacj± jest $AddCurrency$, która na podstawie kodu ISO oraz warto¶ci w stosunku do dolara dodaje do systemu definicjê waluty. Korzystamy tutaj z konstrukcji niezgodnej z ZRM, ale zgodnej z Z/EVES i standardem ISO (standard ISO okre¶la j± inn± sk³adni±).

Warunkiem wstêpnym operacji jest, ¿e nie istnieje taka waluta w systemie, która ma identyczny kod ISO.

\begin{schema}{AddCurrency }  \Delta PORTFOLIO \\ 
  isocode?: CHARS \\ 
  usdratio?: FLOAT \\ 
\where \\ 
  \lnot (\exists x: CURRENCY @ x.iso\_code = isocode?) \\ 
  currencies' = currencies \cup \\
\t2		\{\theta  CURRENCY[iso\_code := \langle \rangle , usd\_ratio := usdratio?]\} 
\end{schema} 

Operacja $FindCurrency$ nie zmienia stanu systemu. Jej zadaniem jest znalezienie waluty w systemie, której kod ISO jest zgodny z zadanym.

Warunkiem wstêpnym operacji jest to, ¿e istnieje dok³adnie jedna taka waluta w systemie.

\begin{schema}{FindCurrency }  \Xi PORTFOLIO \\ 
  isocode?: CHARS \\ 
  out!: CURRENCY \\ 
\where \\ 
  \exists_1 x: currencies @ x.iso\_code = isocode? \\ 
  out! = (\mu x: currencies | x.iso\_code = isocode?) 
\end{schema} 

Dla udowodnienia poprawno¶ci tej definicji, musimy u¿yæ dowodu przez redukcjê.

\begin{zproof}
        prove by reduce
\end{zproof}

Na podstawie podanego zbioru wi±zañ schematu $CURRENCY$, operacja $GetRatio$ zwraca warto¶æ waluty.

\begin{zed}
GetRatio \defs \\
\t1  [~ currency?: CURRENCY; ratio!: FLOAT | ratio! = currency?.usd\_ratio ~] 
\end{zed}

Operacja $GetCurrencyRatio$ jest potokiem, który tworzy schemat operacji akceptuj±cej kod ISO i zwracaj±cej warto¶æ waluty w stosunku do dolara.

\begin{zed}
GetCurrencyRatio \defs FindCurrency \pipe GetRatio [~ out!/currency? ~] 
\end{zed}

Operacja $DeleteCurrencyBindings$ zmienia stan systemu w ten sposób, ¿e usuwana jest waluta o podanym zbiorze wi±zañ, pod warunkiem, ¿e ¿adna spó³ka nie jest zwi±zana z t± walut±. Je¶li istnieje spó³ka, która ma przypisan± dan± walutê, to aby j± usun±æ, trzeba równie¿ usun±æ spó³kê. W ten sposób zachowane s± niezmienniki struktur.

Warunkiem wstêpnym jest te¿ wystêpowanie instancji podanej waluty w systemie.

\begin{schema}{DeleteCurrencyBindings }  \Delta PORTFOLIO \\ 
  currency?: CURRENCY \\ 
\where \\ 
  currency? \in currencies \\ 
  \forall x: stock\_ids @ x.currency \neq currency? \\ 
  currencies' = currencies \setminus \{currency?\} 
\end{schema} 

Operacja $DeleteCurrency$ realizuje to samo co poprzednia, ale wymaga podania tylko kodu ISO. 

\begin{zed}
DeleteCurrency \defs FindCurrency \pipe DeleteCurrencyBindings [~ out!/currency? ~] 
\end{zed}

\subsection{Operacje na punktach danych dla spó³ek}

Zbiory punktów danych przechowuj± informacjê o notowaniach.

Maj±c dan± spó³kê i sesjê, mo¿emy dodaæ do systemu informacjê o notowaniach dziennych. Warunkiem wstêpnym jest, ¿e spó³ka $stock?$ musi istnieæ w systemie. 

Aby zdefiniowaæ tak± operacjê, musimy rozpatrzyæ dwa przypadki. Pierwszy, ¿e informacja o punktach danych z podanej spó³ki, na okre¶lonej sesji nie zosta³a jeszcze wprowadzona do systemu. Mo¿emy wtedy u¿yæ operatora przeci±¿enia $\oplus$.

Je¶li w systemie nie istnieje informacja o podanej sesji, to jest ona wprowadzana do systemu.

\begin{schema}{AddDailyData }  \Delta PORTFOLIO \\ 
  stock?: STOCKREC \\ 
  session?: SESSIONREC \\ 
  vals?: VALUES \\ 
\where \\ 
  stock? \in stock\_ids \\ 
  stock? \notin \dom daily\_data \\ 
  sessions' = sessions \cup \{session?\} \\ 
  daily\_data' = daily\_data \oplus \{(stock? \mapsto \{(session? \mapsto vals?)\})\} 
\end{schema} 

Drugi przypadek: informacja by³a ju¿ wprowadzona, nie mo¿emy wiêc u¿yæ bezpo¶rednio operatora przeci±¿enia, gdy¿ skasowaliby¶my stare dane. £±czymy wiêc stare i nowe dane w jeden zbiór, korzystaj±c z funkcji czê¶ciowej $daily\_data$.

Warunek wstêpny ? ¿e istniej± punkty danych dla podanej sesji i spó³ki ? jest jednocze¶nie warunkiem poprawno¶ci u¿ycia funkcji $daily\_data$, gwarantuje wiêc poprawno¶æ ca³ej definicji.

\begin{schema}{UpdateDailyData }  \Delta PORTFOLIO \\ 
  stock?: STOCKREC \\ 
  session?: SESSIONREC \\ 
  vals?: VALUES \\ 
\where \\ 
  stock? \in stock\_ids \\ 
  stock? \in \dom daily\_data \\ 
  sessions' = sessions \cup \{session?\} \\ 
  daily\_data' = daily\_data \oplus \\
\t1	\{(stock? \mapsto daily\_data stock? \cup \{(session? \mapsto vals?)\})\} 
\end{schema} 

Skrypt dowodu:

\begin{zproof}
       rewrite 
\end{zproof}

£±czymy oba przypadki i otrzymujemy definicjê dodania punktu danych {\it daily} do systemu.

\begin{zed}
AddDailyPoint \defs AddDailyData \lor UpdateDailyData 
\end{zed}

Analogiczna konstrukcja zosta³a wykorzystana w definicji dla danych ci±g³ych.

\begin{schema}{AddIntradayData }  \Delta PORTFOLIO \\ 
  stock?: STOCKREC \\ 
  session?: SESSIONREC \\ 
  time?: TIME \\ 
  vals?: VALUES \\ 
\where \\ 
  stock? \in stock\_ids \\ 
  stock? \notin \dom intra\_data \\ 
  sessions' = sessions \cup \{session?\} \\ 
  intra\_data' = intra\_data \oplus \\
\t1	\{(stock? \mapsto \{(session? \mapsto (time? \mapsto vals?))\})\} 
\end{schema} 

\begin{schema}{UpdateIntradayData }  \Delta PORTFOLIO \\ 
  stock?: STOCKREC \\ 
  session?: SESSIONREC \\ 
  time?: TIME \\ 
  vals?: VALUES \\ 
\where \\ 
  stock? \in stock\_ids \\ 
  stock? \in \dom intra\_data \\ 
  sessions' = sessions \cup \{session?\} \\ 
  intra\_data' = intra\_data \oplus \\
\t1	 \{(stock? \mapsto intra\_data ~ stock? \cup \{(session? \mapsto (time? \mapsto vals?))\})\} 
\end{schema} 

Skrypt dowodu:

\begin{zproof}
       rewrite
\end{zproof}

Operacja dodania punktu notowañ ci±g³ych.

\begin{zed}
AddIntradayPoint \defs AddIntradayData \lor UpdateIntradayData 
\end{zed}

Operacja skasowania wszystkich notowañ dla podanej spó³ki:

\begin{schema}{DeletePointsForStock }  \Delta PORTFOLIO \\ 
  stock?: STOCKREC \\ 
\where \\ 
  daily\_data' = \{stock?\} \ndres daily\_data \\ 
  intra\_data' = \{stock?\} \ndres intra\_data 
\end{schema} 

Operacja $GetDailyValues$ zwraca pojedynczy punkt danych dziennych na podstawie podanej spó³ki I sesji. Jej warunkiem wstêpnym jest istnienie takiej spó³ki wraz  z informacj± o podanej sesji.

\begin{schema}{GetDailyValues }  \Xi PORTFOLIO \\ 
  stock?: STOCKREC \\ 
  session?: SESSIONREC \\ 
  vals!: VALUES \\ 
\where \\ 
  stock? \in \dom daily\_data \\ 
  session? \in \dom (daily\_data ~ stock?) \\ 
  daily\_data ~ stock? ~ session? \in VALUES \\ 
  vals! = (\mu x: VALUES | x = daily\_data ~ stock? ~ session?) 
\end{schema} 

Skrypt dowodu:

\begin{zproof}
       rewrite
\end{zproof}

Operacja $FindSessions$ zwraca instancjê schematu $SESSIONREC$ na podstawie daty. Jej warunkiem wstêpnym jest prawid³owo¶æ tej daty (musi istnieæ informacja o sesji w danym dniu). 

Operacja ta nie zmienia stanu systemu.

\begin{schema}{FindSession }  \Xi PORTFOLIO \\ 
  date?: DATE \\ 
  out!: SESSIONREC \\ 
\where \\ 
  \exists_1 x: sessions @ x.session\_date = date? \\ 
  out! = (\mu x: sessions | x.session\_date = date?) 
\end{schema} 

Dowód:

\begin{zproof}
       rewrite
\end{zproof}

Operacja $GetDailyValuesByDate$ za pomoc± operatora potoku $\pipe$ definiuje pobranie punktu danych maj±c dan± datê.

\begin{zed}
GetDailyValuesByDate \defs FindSession \pipe GetDailyValues[out!/session?] 
\end{zed}

\subsection{Operacje na alarmach}

Aby okre¶liæ na podstawie danych alarmu i notowañ, czy dany alarm powinien byæ aktywny czy nie, potrzebujemy jakiej¶ funkcji. W tym celu definiujemy relacjê $active\_alarm\_values$. Ta relacja powinna byæ w³a¶ciwie funkcj± ca³kowit±, ale wtedy dowód w Z/EVES jest o wiele trudniejszy.

W specyfikacji nie jest okre¶lony sposób implementacji tej funkcji, pozostawione jest to programi¶cie.

\begin{axdef} 
  active\_alarm\_values: \power (ALARMREC \cross VALUES) 
\end{axdef} 

W taki sam sposób jak wprowadzanie notowañ definiujemy dodawanie nowych alarmów do systemu. 

\begin{schema}{AddAlarmData }  \Delta PORTFOLIO \\ 
  alarm?: ALARMREC \\ 
  stock?: STOCKREC \\ 
\where \\ 
  stock? \in stock\_ids \\ 
  stock? \notin \dom alarms \\ 
  alarms' = alarms \oplus \{(stock? \mapsto \{alarm?\})\} 
\end{schema} 

\begin{schema}{UpdateAlarmData }  \Delta PORTFOLIO \\ 
  alarm?: ALARMREC \\ 
  stock?: STOCKREC \\ 
\where \\ 
  stock? \in stock\_ids \\ 
  stock? \in \dom alarms \\ 
  alarms' = alarms \oplus \{(stock? \mapsto alarms ~ stock? \cup \{alarm?\})\} 
\end{schema} 

Dowód:

\begin{zproof}
      prove by reduce 
\end{zproof}

Warunkiem wstêpnym operacji ³±cznej jest wystêpowanie informacji o podanej spó³ce.

\begin{zed}
AddAlarm \defs AddAlarmData \lor UpdateAlarmData 
\end{zed}

Operacja $IsStockActiveForVals$, na podstawie danej spó³ki i notowañ pozwala na okre¶lenie, czy powinien byæ dla niej aktywny alarm (w programie STOCKPACK zaimplementowano to wystêpowaniem ikonki dzwoneczka obok jej nazwy).

\begin{schema}{IsStockActiveForVals }  \Xi PORTFOLIO \\ 
  stock?: STOCKREC \\ 
  vals?: VALUES \\ 
\where \\ 
  \exists arec: ALARMREC @ \\ 
\t1     stock? \in \dom alarms \land arec \in alarms ~ stock? \\ 
\t2     \implies arec \mapsto vals? \in active\_alarm\_values 
\end{schema} 

Dowód:

\begin{zproof}
       rewrite
\end{zproof}

Operacja potoku $IsStockActive$ eliminuje potrzebê podawania danych $VALUES$. Stan alarmu dla danej spó³ki otrzymujemy podaj±c jej instancjê oraz datê.

\begin{zed}
IsStockActive \defs GetDailyValues \pipe IsStockActiveForVals[vals!/vals?] 
\end{zed}

Operacja $DeleteAlarmsForStock$ usuwa wszystkie alarmy dla podanej spó³ki.

\begin{schema}{DeleteAlarmsForStock }  \Delta PORTFOLIO \\ 
  stock?: STOCKREC \\ 
\where \\ 
  alarms' = \{stock?\} \ndres alarms 
\end{schema} 

\subsection{Operacje na transakcjach}

Podrozdzia³ ten specyfikuje funkcjonalno¶æ portfela STOCKPACK.

Pierwsza operacja znakuje transakcjê stemplem czasowym. Jest okre¶lona na schemacie $TRANSACTIONREC$.

\begin{schema}{MarkTransactionTimestamp }  \Delta 
TRANSACTIONREC \\ 
\where \\ 
  mod\_date' = today \\ 
  mod\_time' = now 
\end{schema} 

$DoTransaction$ jest operacj± ogólnego przeznaczenia, oznaczaj±c± wykonanie jakiej¶ transakcji. Dziêki zastosowaniu s³ów kluczowych $\IF \THEN \ELSE$ wyeliminowana jest konieczno¶æ stosowania dwóch przypadków, tak jak w poprzednich paragrafach. Wykonana transakcja dodawana jest do systemowego rejestru transakcji.

\begin{schema}{DoTransaction }  \Delta PORTFOLIO \\ 
  stock?: STOCKREC \\ 
  record?: TRANSACTIONREC \\ 
  type?: TRANSTYPE \\ 
  merged: \power (TRANSTYPE \cross TRANSACTIONREC) \\ 
\where \\ 
  \IF stock? \in \dom transactions \\ 
  \THEN merged = transactions ~ stock? \cup \{(type? \mapsto record?)\} \\ 
  \ELSE merged = \{type? \mapsto record?\} \\ 
  transactions' = transactions \oplus \{(stock? \mapsto merged)\} 
\end{schema} 

Dowód:

\begin{zproof}
       rewrite
\end{zproof}

Definicja transakcji kupna wykorzystuje operator z³o¿enia oraz podstawienie:

\begin{zed}
Buy \defs MarkTransactionTimestamp \comp DoTransaction[type? := BUY] 
\end{zed}

Analogicznie transakcja sprzeda¿y:

\begin{zed}
Sell \defs MarkTransactionTimestamp \comp DoTransaction[type? := SELL] 
\end{zed}

Operacja usuwania z rejestru transakcji wszystkich nale¿±cych do danej spó³ki.

\begin{schema}{DeleteTransactionsForStock }  \Delta PORTFOLIO 
\\ 
  stock?: STOCKREC \\ 
\where \\ 
  transactions' = \{stock?\} \ndres transactions 
\end{schema} 

\subsection{Operacje na spó³kach}

Po zdefiniowaniu wszystkich wa¿niejszych operacji sk³adowych pora na operacje, które pozwalaj± na modyfikacjê danych z punktu widzenia jednej spó³ki.

Operacja $AddStock$ za pomoc± operatora $\theta$ dodaje do systemu zbiór wi±zañ odpowiadaj±cy nowej spó³ce.

\begin{schema}{AddStock }  \Delta PORTFOLIO \\ 
  myname?, mysymbol?: CHARS \\ 
\where \\ 
  stock\_ids' = stock\_ids \cup \\ 
\t1      \{STOCKREC[name := myname?, symbol := mysymbol?, \\
\t2		currency := usd\_currency, source\_id := default\_source, \\ 
\t2		mod\_date := 0, mod\_time := 0]\} 
\end{schema} 

Usuniêcie definicji spó³ki z tabeli:

\begin{schema}{DeleteStockData }  \Delta PORTFOLIO \\ 
  stock?: STOCKREC \\ 
\where \\ 
  stock\_ids' = stock\_ids \setminus \{stock?\} 
\end{schema} 

Operacja $DeleteStock$ kasuje wszystkie elementy w systemie zwi±zane z dan± spó³k±. Wykluczona jest wiêc sytuacja, w której w systemie znajduj± siê jakie¶ dane dla nieokre¶lonej spó³ki, co spe³nia warunki odpowiednich niezmienników systemowych.

\begin{zed}
DeleteStock \defs \\
\t1  DeleteStockData \\
\t1  \land DeletePointsForStock \\
\t1  \land DeleteAlarmsForStock \\
\t1  \land DeleteTransactionsForStock \\
\end{zed}

\subsection{Operacje na portfolio}

Poniewa¿ w niniejszej specyfikacji pojêcie portfolio nie zosta³o zbytnio przybli¿one, a 
u¿yte jedynie w celu po³±czenia ze sob± wszystkich elementów systemu, okre¶lona jest 
tylko jedna operacja zmieniaj±ca nazwê portfolio:

\begin{schema}{SetStockName }  \Delta PORTFOLIO \\ 
  newname?: CHARS \\ 
\where \\ 
  portfolio\_name' = newname? 
\end{schema} 


\section{Wnioski koñcowe}

W systemie STOCKPACK zaimplementowano czê¶æ funkcjonalno¶ci, która nie jest opisana 
specyfikacj± w tym rozdziale, ale ze wzglêdów objêto¶ciowych przytoczone zosta³y najwa¿niejsze 
czê¶ci oddaj±ce ideê wspomagania projektowania metodami formalnymi. Specyfikacja ta formalizuje 
dostêp do danych, dowodz±c przydatno¶ci notacji \zet i systemu Z/EVES w zastosowaniach 
baz danych.

\chapter{Zakoñczenie}

Notacja \zet jest jednym z najbardziej rozbudowanych i uniwersalnych systemów formalnego
opisu oprogramowania. Jej stosowanie mo¿e stwarzaæ wiele korzy¶ci, zarówno dla projektantów,
jak i programistów. Niestety, jak w wielu innych przypadkach, uniwersalno¶æ jest osi±gniêta
kosztem mniejszej u¿yteczno¶ci dla specyficznych zastosowañ. W chwili obecnej, pomimo faktu,
¿e prace nad \zet s± intensywnie prowadzone, wydaje siê, ¿e nie jest to metoda, która ma 
szansê sukcesu w komercyjnych przedsiêwziêciach. Przede wszystkim, wbrew zapewnieniom autorów
u¿ywanie notacji jest trudne. Oprócz znajomo¶ci samego rozbudowanego aparatu matematycznego, 
zawieraj±cego logikê, rachunek predykatów, teoriê mnogo¶ci i wiele elementów z innych dziedzin,
projektant musi siê czêsto wykazaæ zdolno¶ci± przeprowadzania dowodów, umieæ prze³o¿yæ pojêcia
czasem wydaj±ce siê oczywistymi (np. liczba rzeczywista) na jêzyk notacji, a tak¿e posiadaæ
du¿e do¶wiadczenie. Niestety umiejêtno¶ci takie o wiele trudniej jest zdobyæ i opanowaæ,
ani¿eli nauczyæ siê jednego z dostêpnych na rynku narzêdzi, zazwyczaj przedstawiaj±cych
zawi³e problemy, np. z tematyki baz danych, w formie graficznej i diagramów, a nie ¶cis³ych
symboli matematycznych.

Z ekonomicznego punktu widzenia, pomimo potencjalnych korzy¶ci finansowych, wynikaj±cych ze
zmniejszenia nak³adów na testowanie i usuwanie poprawek, konieczno¶æ zatrudnienia specjalistów
posiadaj±cych wiedzê nt. metod formalnych zwiêksza bud¿et projektu. Zw³aszcza, ¿e notacjê i formalne 
zapisy musz± równie¿ rozumieæ programi¶ci, którzy na podstawie specyfikacji implementuj±
system. Mo¿na wiêc zaryzykowaæ twierdzenie, ¿e zespó³ projektowy, stosuj±cy metody formalne
takie jak \zet, musi sk³adaæ siê ze specjalistów wysokiej klasy i z du¿ym do¶wiadczeniem,
co nie jest konieczno¶ci± dla ka¿dego projektu informatycznego.

Innym problemem jest niewielka baza do¶wiadczeñ, z jakiej mo¿e korzystaæ projektant. Jest
wiele zbadanych i opisanych zagadnieñ, zaliczaj±cych siê do kanonu wspó³czesnej 
informatyki, których znajomo¶æ jest niezbêdna do tworzenia oprogramowania bêd±cego
w stanie sprostaæ przyjêtym standardom. Dotyczy to zarówno algorytmów i struktur 
danych (pojêcia jak z³o¿ono¶æ, sortowanie, wyszukiwanie), jak i kryptografii, baz danych,
budowy jêzyków, lub przetwarzania równoleg³ego. Czêsto jednak¿e zagadnienia te nie s±
opisane za pomoc± pojêæ znanych z teorii mnogo¶ci lub rachunku predykatów. Powoduje to,
¿e opisanie ich za pomoc± \zet jest niejednokrotnie bardzo trudne.

Wydaje mi siê, ¿e stanowi to barierê w rozwoju metod formalnych. Dopóki nie zostanie 
stworzona baza do¶wiadczeñ, jednoznacznie opisuj±ca choæby te przyk³adowe pojêcia, 
dopóty projektanci i programi¶ci bêd± wybieraæ prostsze narzêdzia, ale przeznaczone 
do konkretnych zastosowañ. Optymistyczny jest fakt, ¿e zosta³o wykonane
wystarczaj±co du¿o pracy, ¿eby metody formalne przekroczy³y próg labolatoriów i uczelni.
Ich zastosowanie w konkretnych projektach jest mo¿liwe ju¿ dzisiaj. S±dzê, ¿e w miarê
up³ywu czasu sytuacja siê poprawi, bêdzie to jednak proces d³ugotrwa³y.

\appendix

\chapter{Zestawienie stosowanych operatorów \zet}

\section{Jêzyk matematyczny}

\subsection{Zbiory}

\subsubsection*{Zestawienie operatorów}

\begin{tabular}{l l}
\hline
\bf{Symbol} & \bf{Znaczenie} \\
\hline
$\emptyset$ & Zbiór pusty: zbiór, który nie zawiera ¿adnego elementu \\
$x \notin S$ & Niezawieranie siê: $x$ nie jest elementem $S$ \\
$S \subseteq T$ & Podzbiór: wszystkie elementy z $S$ nale¿± do $T$ \\
$S \subset T$ & Podzbiór w³a¶ciwy: $S$ jest podzbiorem $T$ i $S$ nie jest równy $T$ \\
$S \cup T$ & Suma zbiorów: zbiór elementów zawieraj±cych siê w $S$ lub w $T$ \\
$S \cap T$ & Iloczyn zbiorów: zbiór elementów zawieraj±cych siê zarówno w $S$ \\
~	   & jak i w $T$ \\
$S \setminus T$ & Ró¿nica zbiorów: zbiór elementów $S$, które nie zawieraj± siê w $T$ \\
$\power X$ & Potêga zbioru: zbiór wszystkich podzbiorów zbioru $X$ \\
\hline
\end{tabular}

\subsubsection*{Definicje}

Oto przyk³ad formalnej definicji tych pojêæ w sposób znany z podrêczników matematyki.
Do wyspecyfikowania podanych operatorów u¿yty zosta³ jêzyk schematów notacji Z, który zostanie
przedstawiony w nastêpnym rozdziale.

\begin{zed} \emptyset[X] == \{~ x: X | false ~\} \end{zed}

\begin{gendef}[X]
	\_ \subseteq \_, \_ \subset \_ : \power X \rel \power X \\ 
   	\_ \cup \_ , \_ \cap \_, \_ \setminus \_: \power X \cross \power X \fun \power X \\
\where
	\forall x: X; y: Y; S, T: \power X @ 
\also
\t1	x \notin S \iff \lnot (x \in X) \land
\also
\t1	(S \subseteq T \iff (\forall x: X @ x \in S \implies x \in T)) \land
\also
\t1	(S \subset T \iff S \subseteq T \land S \neq T) \land
\also 
\t1	S \cup T = \{~ x: X | x \in S \lor X \in T ~\} \land
\also 
\t1	S \cap T = \{~ x: X | x \in S \land X \in T ~\} \land
\also 
\t1	S \setminus T = \{~ x: X | x \in S \land X \notin T ~\}
\also
\end{gendef}

\subsection{Pary i relacje binarne I}

\subsubsection*{Zestawienie operatorów}

\begin{tabular}{l l}
\hline
\bf{Symbol} & \bf{Znaczenie} \\
\hline
$(x,y)$	  & Para $x$,$y$ \\
$x \mapsto y$ & Wskazywanie: $x$ wskazuje $y$, to samo co $(x,y)$ \\
$first~p$ & Pierwszy element pary $p$ \\
$second~p$ & Drugi element pary $p$ \\
$\id X$ & Relacja identyczno¶ci \\
$X \rel Y$ & Relacja binarna \\
$\dom R$ & Dziedzina: zbiór pierwszych elementów wszystkich par z $R$ \\
$\ran R$ & Zbiór warto¶ci: zbiór drugich elementów wszystkich par z $R$ \\
\hline
\end{tabular}

\subsubsection*{Definicje}

\begin{zed} 
	X \rel Y == \power (X \cross Y)
\also
	\id X == \{ x: X @ x \mapsto x \}
\end{zed}

\begin{gendef}[X,Y]
	first: X \cross Y \fun X \\
	second: X \cross Y \fun Y \\
	\_ \mapsto \_ : X \cross Y \fun X \cross Y \\
	\dom: (X \rel Y) \fun \power X \\
	\ran: (X \rel Y) \fun \power Y \\
\where
	\forall x: X; y: Y; R: X \rel Y @ \\
\also
\t1	first(x,y) = x \land
\also
\t1	second(x,y) = y \land
\also
\t1	x \mapsto y = (x,y) \land
\also
\t1	\dom R = \{~ x: X; y: Y | x \inrel{R} y @ x ~\} \land	
\also
\t1	\ran R = \{~ x: X; y: Y | x \inrel{R} y @ y ~\}
\also
\end{gendef}

\subsection{Pary i relacje binarne II}

\subsubsection*{Zestawienie operatorów}

\begin{tabular}{l l}
\hline
\bf{Symbol} & \bf{Znaczenie} \\
\hline
$S \dres R$ & Wszystkie pary z $R$ których pierwszy element nale¿y do $S$ \\
$R \rres T$ & Wszystkie pary z $R$ których drugi element nale¿y do $T$ \\
$S \ndres R$ & Wszystkie pary z $R$ których pierwszy element nie nale¿y do $S$ \\
$R \nrres T$ & Wszystkie pary z $R$ których drugi element nie nale¿y do $T$ \\
$R \inv$ & Relacyjna odwrotno¶æ: pary z $R$, \\
	&  w których zamieniony jest pierwszy i drugi element \\
$R \limg S \rimg$ & Relacyjny obraz: drugie elementy par \\
		&  z $R$ których pierwszy element nale¿y do $S$. \\
$R \oplus Q$ & Przeci±¿anie: wszystkie pary z $R$ lub z $Q$, \\
	& oprócz par z $R$ których pierwszy element nale¿y równie¿ do $Q$. \\
$R \plus$ & Przechodnie domkniêcie $R$ \\
\hline
\end{tabular}

\subsubsection*{Definicje}

\begin{gendef}[X,Y]
	\_ \dres \_, \_ \ndres \_ : \power X \cross (X \rel Y) \fun X \rel Y \\
	\_ \rres \_, \_ \nrres \_ : (X \rel Y)  \cross  \power Y \fun X \rel Y \\
	\_ \inv : (X \rel Y) \fun (Y \rel X) \\
	\_ \limg \_ \rimg : (X \rel Y) \cross \power X \fun \power Y \\
	\_ \oplus \_ : (X \rel Y) \cross (X \rel Y) \fun (X \rel Y) \\
	\_ \plus : (X \rel X) \fun (X \rel X)
\where
	\forall x: X; y: Y; S: \power X; T: \power Y; Q, R: X \rel Y @ \\
\also
\t1 S \dres R = \{~ x: X; y: Y | x \in S \land x \inrel{R} y @ x \mapsto y ~\} \land	
\also
\t1 S \ndres R = \{~ x: X; y: Y | x \notin S \land x \inrel{R} y @ x \mapsto y ~\} \land	
\also
\t1 R \rres T = \{~ x: X; y: Y | x \inrel{R} y \land y \in T @ x \mapsto y ~\} \land	
\also
\t1 R \nrres T = \{~ x: X; y: Y | x \inrel{R} y \land y \notin T @ x \mapsto y ~\} \land	
\also	
\t1	R \inv = \{~ x: X; y: Y | x \inrel{R} y @ y \mapsto x ~\} \land \\
\also 
\t1 R \limg S \rimg = \{~ x: X; y: Y | x \in S \land x \inrel{R} y @ y ~\} \land	
\also
\t1	Q \oplus R = ((\dom R) \ndres Q) \cup R
\also
\t1	\mbox{\dots predykat dla $\_ \plus$ pominiêty \dots}
\also
\end{gendef}


\subsection{Pary i relacje binarne III}

\subsubsection*{Zestawienie operatorów}

\begin{tabular}{l l}
\hline
\bf{Symbol} & \bf{Znaczenie} \\
\hline
$Q \comp R$ & Z³o¿enie relacji: $Q$ z³o¿ona z $R$ \\
$R \circ Q$ & To samo co $Q \comp R$ \\
\hline
\end{tabular}

\subsubsection*{Definicje}

\begin{gendef}[X,Y,Z]
	\_ \comp \_ : (X \rel Y) \cross (Y \rel Z) \fun (X \rel Z) \\
	\_ \circ \_ : (Y \rel Z) \cross (X \rel Y) \fun (X \rel Z) \\
\where
	\forall Q: X \rel Y; R: Y \rel Z @ \\
\t2		Q \comp R = R \circ Q = \{~ x: X; y: Y; z: Z | x \inrel{Q} y \land y \inrel{R} z @ x \mapsto z ~\}
\end{gendef}

\subsection{Liczby i arytmetyka}

\subsubsection*{Zestawienie operatorów}

\begin{tabular}{l l}
\hline
\bf{Symbol} & \bf{Znaczenie} \\
\hline
$\num$ & Zbiór liczb ca³kowitych \\
$\nat$ & Zbiór liczb naturalnych wraz z zerem \\
$\nat_1$ & Zbiór liczb naturalnych dodatnich (bez zera) \\
$+,-,*$ & Operatory arytmetyczne: suma, ró¿nica, mno¿enie \\
$\div,\mod$ & Operatory arytmetyczne: dzielenie ca³kowite i reszta z dzielenia \\
$<,\leq$ & Porównanie: mniejsze, mniejsze lub równe \\
$>, \geq$ & Porównanie: wiêksze, wiêksze lub równe \\
$i \upto j$ & Zakres: zbiór liczb ca³kowitych od $i$ do $j$ \\
$min~S$ & Minimum: najwiêkszy element $S$ (je¶li istnieje) \\
$max~S$ & Maksimum: najwiêkszy element $S$ (je¶li istnieje) \\
$\# S$	& Liczno¶æ: liczba elementów nale¿±cych do zbioru $S$ \\
$\power_1$ & Zbiory niepuste \\
$\finset$ & Zbiory skoñczone \\
\hline
\end{tabular}

\subsubsection*{Definicje}

\begin{zed} 
	[\num]
\also
	\nat == \{~ n: \num | n \geq 0 ~\}
\also
	\nat_1 == \nat \setminus \{ 0 \}
\also
	\power_1 X == \{~ S: \power X | S \neq \emptyset ~\}
\also
	\finset X == \{~ S: \power X | \mbox{\dots $S$ jest skoñczony \dots} ~\}
\end{zed}

\begin{axdef}
	\_ + \_, \_ - \_, \_* \_ : \num \cross \num \fun \num \\
      \_ \div \_, \_ \mod \_ : \num \fun (\num \setminus \{ 0 \}) \fun \num \\
	\_ - : \num \fun \num \\
	\_ < \_, \_ \leq \_, \_ \geq \_, \_ > \_ : \num \rel \num \\
	\_ \upto \_ : \num \rel \num \fun \power \num \\
	\#: \finset X \fun \nat \\
	min, max: \power_1 \num \pfun \num
\where
	\forall a,b: \num @ a \upto b = \{~ i: \num | a \leq i \leq b ~\} \\
\also
\t1	\mbox{\dots predykaty dla innych operatorów pominiête \dots}
\end{axdef}

\subsection{Funkcje}

\subsubsection*{Zestawienie operatorów}

\begin{tabular}{l l}
\hline
\bf{Symbol} & \bf{Znaczenie} \\
\hline
$X \pfun Y$ & Funkcja czê¶ciowa: niektóre elementy zbioru $X$ s± w parze \\
~	    & z elementem z $Y$ \\
$X \fun Y$ & Funkcja zupe³na: wszystkie elementy zbioru $X$ s± w parze \\
~	    & z elementem z $Y$ \\
$X \pinj Y$ & Czê¶ciowa injekcja: niektóre elementy zbioru $X$ s± w parze z innym \\
~	    & elementem z $Y$ \\
$X \inj Y$ & Zupe³na injekcja: wszystkie elementy zbioru $X$ s± w parze z innym \\
~	    & elementem z $Y$ \\
$X \bij Y$ & Bijekcja: ka¿dy element zbioru $X$ jest w parze z innym elementem z $Y$, \\
~	    & pokrywaj±c ca³y zbiór $Y$ \\
\hline
\end{tabular}

\subsubsection*{Definicje}

\begin{zed}
 X \pfun Y == \{~ f: X \rel Y | \mbox{Ka¿dy element z $X$ wystêpuje nie wiêcej ni¿ raz.} ~\}
\also
 X \fun Y == \{~ f: X \pfun Y | \dom f = X ~\}
\also
 X \pinj Y == \\
\t1	\{~ f: X \pfun Y | \mbox{Ka¿dy element z $X$ jest w parze z innym elementem z $Y$.} ~\}
\also
 X \inj Y == (X \pinj Y) \cap (X \fun Y)
\also
 X \bij Y == \mbox{ \dots definicja pominiêta \dots }
\end{zed}

\subsection{Ci±gi (sekwencje)}

\subsubsection*{Zestawienie operatorów}

\begin{tabular}{l l}
\hline
\bf{Symbol} & \bf{Znaczenie} \\
\hline
$\seq X$ & Ci±g: zbiór wszystkich ci±gów z $X$ \\
$\seq_1 X$ & Niepusty ci±g: niepusty zbiór wszystkich ci±gów z $X$ \\
$\iseq X$ & Ci±g pokrywaj±cy: zbiór wszystkich ci±gów z $X$ \\
	& w których ka¿dy element z $X$ wystêpuje tylko raz \\
$s \cat t$ & Konkatenacja: ci±g $s$ z do³±czonym ci±giem $t$ \\
$head~s$ & Pierwszy element ci±gu $s$ \\
$last~s$ & Ostatni element ci±gu $s$ \\
$front~s$ & Ci±g $s$ bez ostatniego elementu \\
$tail~s$ & Ci±g $s$ bez pierwszego elementu \\
$s \inseq t$ & Relacja zawierania: ci±g $s$ jest podci±giem ci±gu $t$ \\
\hline
\end{tabular}

\subsubsection*{Definicje}

\begin{zed}
	\seq X == \{~ f: \nat \ffun X | \dom f = 1 \upto \# f ~\}
\also
	\seq_1 X == \{~ f: \seq X | \# f > 0 ~\}
\also
	\iseq X == \seq X \cap (\nat \pinj X)
\end{zed}

\begin{gendef}[X]
	head, last : \seq_1 X \fun X \\
	tail, front : \seq_1 X \fun \seq X \\
	\_ \cat \_ : \seq X \cross \seq X \fun seq X \\
	\_ \inseq \_ : \seq X \rel \seq X \\
\where
	\forall s: \seq_1 X; u,v: \seq X @ \\
\also 
\t1	head(s) = s(1) \land
\also
\t1	last(s) = s(\# s) \land
\also
\t1	u \cat v = u \cup \{~ i: \dom v @ i + \#u \mapsto v(i) ~\}
\also
\t1	u \inseq v \iff (\exists s,t: \seq X @ s \cat u \cat t = v) 
\also
\t1	\mbox{\dots predykaty dla pozosta³ych operatorów pominiête \dots}
\also
\end{gendef}

\section{Jêzyk schematyczny notacji}

\subsection{Notacja schematów}

\subsubsection*{Definicja schematu}

\begin{schema}{S}
	d
\where
	p
\end{schema}


\subsubsection*{Definicja aksjomatu}

\begin{axdef}
	d
\where
	p
\end{axdef}

\subsubsection*{Definicja uogólniona}

\begin{gendef}[a, \dots]
	d
\where
	p
\end{gendef}

\subsection{Rachunek schematów}

\begin{tabular}{l l}
\hline
\bf{Symbol} & \bf{Znaczenie} \\
\hline
$S \defs [~ X ~]$ & Schemat poziomy \\
$[~ T; \dots | \dots ~]$  & Do³±czanie referencji schematu \\
$z.a$ & Zaznaczenie komponentu schematu (maj±c dane $z:S$) \\
$\theta S$ & Sygnatura \\
$\lnot S$ & Negacja schematu \\
$S \land T$ & Koniunkcja schematów \\
$S \lor T$ & Alternatywa schematów  \\
$S \hide (x_1, \dots, x_n)$ & Ukrywanie \\
$S \semi T$ & Z³o¿enie schematów \\
$S \pipe T$ & Operator potoku \\
$S \project T$ & Projekcja \\
\hline
\end{tabular}

\subsection{Systemy sekwencyjne}

\begin{tabular}{l l}
\hline
\bf{Symbol} & \bf{Znaczenie} \\
\hline
$a?$ & Parametr operacji \\
$a!$ & Rezultat operacji \\
$a$ & Komponent stanu przed operacj± \\
$a'$ & Komponent stanu po operacji \\
$S$ & Stan schematu przed operacj± \\
$S'$ & Stan schematu po operacji \\
$\Delta S$ & Zmiana stanu \\
$\Xi S$ & Niezmienno¶æ stanu \\
\hline
\end{tabular}

% Bibliografia

%
% Dodac: proofpower - dokumentacja
% Dokumentacja CADiZ
%
 
\bibliographystyle{plain}
\begin{thebibliography}{99}

\bibitem{Spivey-ZRM}J. M. Spivey.
{\it The Z Notation: A Reference Manual\/}. \\
Prentice Hall International Series in Computer Science, 2nd edition, 1992.

\bibitem{ISO}ISO/IEC 13568:2002
{\it Information technology - Z formal specification notation, Syntax, type system and semantic.\/} \\ 
International standard.

\bibitem{ISO_draft}ISO.
{\it Z notation.\/} Technical report, ISO/IEC JTC1/SC22 N1970, 1995. \\
ISO CD 13568; Committee Draft of the proposed Z Standard.

\bibitem{Z-EVES-RM}Irwin Meisels and Mark Saaltink.
{\it The Z/EVES 2.0 Reference Manual.\/} \\
Technical Report TR-99-5493-03e, ORA Canada, October 1999.

\bibitem{Z-EVES-MT}Mark Saaltink.
{\it The Z/EVES 2.0 Mathematical Toolkit.\/} \\
Technical Report TR-99-5493-05b, ORA Canada, October 1999.

\bibitem{Z-EVES-UG}Mark Saaltink.
{\it The Z/EVES 2.0 User's Guide.\/} \\
Technical Report TR-99-5493-06, ORA Canada, October 1999.

\bibitem{WD}J. C. P. Woodcock and J. Davies.
{\it Using Z: Specification, Proof and Refinement.\/} \\
Prentice Hall International Series in Computer Science, 1996.

\bibitem{Arthan_freetypes}R.D.Arthan.
{\it On free type definitions in Z.\/} \\
http://lemma-one.com/files/18.ps.

\bibitem{Arthan_arithmetic}R.D.Arthan.
{\it Arithmetic in Z.\/} \\
ftp://ftp.comlab.ox.ac.uk/pub/Zforum/ZSTAN/papers/z-188.ps

\bibitem{Bowen}Jonathan P. Bowen.
{\it Formal Specification and Documentation using Z: A Case Study Approach.\/} \\
International Thomson Computer Press (ITCP), 1996.

\bibitem{Jacky}Jonathan Jacky.
{\it Z examples.\/} \\
http://www.randonc.washington.edu/prostaff/jon/

\bibitem{CICS_Report}Houston I. and King S.
{\it CICS Project Report: Experiences and Results from the Use of Z in IBM.\/} \\
In Prehn S. and Toetenel W.J. (eds.), {\it VDM'91: Formal Software Development Methods},
volume 551 of {\it Lecture Notes in Computing Science}, pages 588-596. \\
Springer-Verlag, October 1991.

\bibitem{Machine_Jacky}Jonathan Jacky.
{\it Specifying a Safety-Critical Control System in Z.\/} \\
In Woodcock J.C.P. and Larsen P.G. (eds.), {\it FME'93: Industrial-Strength
Formal Methods}, volume 670 of {\it Lecture Notes in Computing Science}, pages 388-402. \\
Springer-Verlag, April 1993. Industrial Usage Report.  

\bibitem{NATO_ACCS}Boswell T.
{\it Specification and Validation of a Security Policy Model.\/} \\
In Woodcock J.C.P. and Larsen P.G. (eds.), {\it FME'93: Industrial-Strength Formal Methods}, 
volume 680 of {\it Lecture Notes in Computing Science}, pages 42-51. \\
Springer-Verlag, April 1993. Industrial Usage Report.

\bibitem{British_Rail}King T.
{\it Formalizing British Rail's Signalling Rules.\/} \\
In Naftalin M., Denvir T. and Bertran M. (eds.), {\it FME'94: Industrial Benefit of Formal Methods}, 
volume 873 of {\it Lecture Notes in Computing Science}, pages 45-54. \\
Springer-Verlag, October 1994. Industrial Usage Report.

\bibitem{SWORD}Smith P. and Keighley R.
{\it The Formal Development of a Secure Transaction Mechanism.\/} \\
In Prehn S. and Toetenel W.J. (eds.), {\it VDM'91: Formal Software Development Methods},
volume 551 of {\it Lecture Notes in Computing Science}, pages 457-476. \\
Springer-Verlag, October 1991.

\bibitem{Barros_phd}R. S. M. Barros.
{\it On the Formal Specification and Derivation of Relational Database Applications.\/} \\
PhD Thesis, Department of Computing Science, The University of Glasgow, November, 1994.

\bibitem{Reals}W. R. Oliveira and R. S. M. Barros.
{\it The Real Numbers in Z.\/} \\
In A. Evans and D. Duke (eds.), {\it Second BCS-FACS Northern Formal Methods Workshop},
Electronic Workshops in Computing. \\
Springer-Verlag, July 1997.

\bibitem{Toyn_ISO}I. Toyn.
{\it Innovations in the Notation of Standard Z\/} \\
ZUM'98: {\it The Z Formal Specification Notation}, LNCS 1493, pp193-213 \\
Springer-Verlag, Berlin, September 1998

\bibitem{ObjectZ_91}Duke R. and King P. and Rose G. and Smith G.
{\it The Object-Z Specification Language: Version 1\/} \\
Software Verification Research Centre, The University of Queensland. Available at
{\it http://svrc.it.uq.edu.au/Bibliography/svrc-tr.html?91-01}.

\bibitem{ObjectZ_94}Duke R. and Rose G. and Smith G.
{\it Object-Z: A Specification Language Advocated for the Description of Standards.\/} \\
Software Verification Research Centre, The University of Queensland. Available at
{\it http://svrc.it.uq.edu.au/Bibliography/svrc-tr.html?94-45}.

\bibitem{Aeronic}Aeronic.
{\it Strona firmy Aeronic.\/} \\
http://www.aeronic.com

\end{thebibliography}


\end{document}

